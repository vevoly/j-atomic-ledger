# j-atomic-ledger
#### ä½œè€… Authorï¼šVEVOLY
> **åŸºäº LMAX æ¶æ„çš„ Java é«˜æ€§èƒ½å†…å­˜äº¤æ˜“å¼•æ“ï¼Œå•æœºç™¾ä¸‡ TPSï¼Œæ”¯æŒ WAL æŒä¹…åŒ–ä¸ç§’çº§å´©æºƒæ¢å¤ï¼Œå¯é›†ç¾¤éƒ¨ç½²ã€‚**  
> A Java high-performance memory transaction engine based on the LMAX architecture, single machine million TPS, supports WAL persistence and second-level crash recovery. support Cluster deployment.
---
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)
[![JDK](https://img.shields.io/badge/JDK-17%2B-green.svg)]()
[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.x-brightgreen.svg)]()
---
![img.png](img%2Fimg.png)
> æ­¤æ¬¡æµ‹è¯•æ˜¯åœ¨ Mac M1 èŠ¯ç‰‡åªæœ‰4æ ¸çš„ç¯å¢ƒä¸‹è·‘å‡ºï¼Œå•æ ¸è·‘å‡º10ä¸‡TPSã€‚è‹¥æ˜¯16æ ¸æœåŠ¡å™¨ï¼Œè½»æ¾ä¸Šç™¾ä¸‡TPSã€‚  
> This test is run on a Mac M1 chip with only 4 cores, achieving 100,000 TPS. If it is a 16-core server, it can easily reach millions of TPS.
---

## ğŸ“– 1. Introduction / é¡¹ç›®ç®€ä»‹

### 1.1 é¡¹ç›®æ¦‚è¿° ğŸ‡¨ğŸ‡³
**j-atomic-ledger** æ˜¯ä¸“ä¸º **é«˜å¹¶å‘ï¼ˆHigh Concurrencyï¼‰** å’Œ **ä½å»¶è¿Ÿï¼ˆLow Latencyï¼‰** åœºæ™¯è®¾è®¡çš„é€šç”¨å†…å­˜äº¤æ˜“å¼•æ“ã€‚
åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œæ•°æ®åº“è¡Œé”ï¼ˆRow Lockï¼‰å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚**j-atomic-ledger** é‡‡ç”¨ **å†…å­˜äº‹ä»¶æº¯æºï¼ˆIn-Memory Event Sourcingï¼‰** æ¶æ„ï¼Œ
å°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œé€šè¿‡ **Disruptor** å®ç°å•çº¿ç¨‹æ— é”å¤„ç†ï¼Œåˆ©ç”¨ **Chronicle Queue** å®ç°çº³ç§’çº§ WAL æŒä¹…åŒ–ï¼Œé…åˆ **Kryo** å†…å­˜å¿«ç…§æŠ€æœ¯ï¼Œ
å®ç°äº†**å•æœºç™¾ä¸‡çº§ TPS** çš„å¤„ç†èƒ½åŠ›ï¼ŒåŒæ—¶ä¿è¯äº†æ•°æ®çš„ç»å¯¹å®‰å…¨ä¸å¼ºä¸€è‡´æ€§ã€‚  
å®ƒå¹¶ä¸æ˜¯è¦å–ä»£æ•°æ®åº“ï¼Œè€Œæ˜¯ä½œä¸ºæ•°æ®åº“çš„å‰ç½®é«˜æ€§èƒ½**å†™ç¼“å†²ä¸è®¡ç®—æ ¸å¿ƒ**ï¼Œç‰¹åˆ«é€‚ç”¨äº**æ”¯ä»˜ç»“ç®—ã€è®¢å•æ’®åˆã€ç§’æ€åº“å­˜æ‰£å‡ã€è´¦å˜**ç­‰å¯¹å¹¶å‘è¦æ±‚æé«˜çš„åœºæ™¯ã€‚
### Project Overview ğŸ‡ºğŸ‡¸
**j-atomic-ledger** is a generic in-memory transaction engine designed for **High Concurrency** and **Low Latency** scenarios.  
In traditional financial/e-commerce architectures, database row locks are often the biggest bottleneck limiting throughput. **j-atomic-ledger** adopts the **In-Memory Event Sourcing** architecture. It moves core calculations from the database to memory, achieving **Single-Node Million-Level TPS** via **Disruptor** (lock-free processing), **Chronicle Queue** (nanosecond-level WAL persistence), and **Kryo** (fast memory snapshot). It ensures absolute data safety and strong consistency.  
It is not intended to replace the database but serves as a high-performance **Write Buffer & Computation Core** in front of it. It is ideal for scenarios such as **Payment Settlement, Order Matching, Flash Sales (Seckill), and Ledger Systems**.

### 1.2 è§£å†³é—®é¢˜ / Problem Solved
#### åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œ**æ•°æ®åº“è¡Œé”** å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚å½“æˆåƒä¸Šä¸‡çš„è¯·æ±‚åŒæ—¶æ“ä½œåŒä¸€ä¸ªè´¦æˆ·æ—¶ï¼Œæ•°æ®åº“è¿æ¥æ± ä¼šè¢«è€—å°½ï¼Œå¯¼è‡´ç³»ç»Ÿç˜«ç—ªã€‚
#### In traditional financial/e-commerce architectures, **Database Row Locks** are often the biggest bottleneck limiting throughput. When thousands of requests hit the same account simultaneously, the database eventually becomes unresponsive.

### 1.3 æ ¸å¿ƒç‰¹æ€§ / Key Features
- ğŸš€ **æè‡´æ€§èƒ½ (Extreme Performance)**: åŸºäº LMAX Disruptor ç¯å½¢é˜Ÿåˆ—ï¼Œå•çº¿ç¨‹æ— é”ä¸²è¡Œæ‰§è¡Œï¼Œæ¶ˆé™¤ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå•æœºè½»æ¾çªç ´ 100ä¸‡+ TPSã€‚  
  Based on LMAX Disruptor. Lock-free, single-threaded execution eliminates context switching.
- ğŸ“¦ **å†…å­˜è®¡ç®— (In-Memory Computing)**: å°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œåˆ©ç”¨ **Kryo** é«˜æ•ˆåºåˆ—åŒ–ä¸ **Chronicle Queue** é«˜æ•ˆ WAL æŒä¹…åŒ–ï¼Œå®ç° **ç§’çº§æ¢å¤**ã€‚  
  Move core computation from database to memory. Utilize **Kryo** for efficient serialization and **Chronicle Queue** for efficient WAL persistence, achieving **fast recovery** in seconds.
- ğŸ’¾ **æ•°æ®å®‰å…¨ (Crash Safe)**: é‡‡ç”¨ Write-Ahead Log (WAL) æœºåˆ¶ï¼Œæ¯ç¬”äº¤æ˜“å…ˆè½ç›˜å†å†…å­˜è®¡ç®—ï¼Œæ”¯æŒæ–­ç”µé›¶ä¸¢å¤±ã€‚  
  Uses Write-Ahead Log (Chronicle Queue). Every transaction is persisted to disk (nanosecond latency) before processing. **Zero data loss on power failure.**
- ğŸ“¸ **ç§’çº§æ¢å¤ (Fast Recovery)**: è‡ªåŠ¨åŒ–çš„å†…å­˜å¿«ç…§ (Snapshot) ä¸å¢é‡æ—¥å¿—é‡æ”¾æœºåˆ¶ï¼ŒæœåŠ¡é‡å¯è€—æ—¶ä»…éœ€æ•°ç§’ã€‚  
  Automated memory snapshots (Kryo) + Incremental WAL replay. Restores millions of records in seconds.
- ğŸ›¡ï¸ **å¹‚ç­‰å»é‡ (Idempotency)**: å†…ç½®åŸºäº BloomFilter å’Œ LRU çš„é«˜æ€§èƒ½å»é‡ç­–ç•¥ï¼Œé˜²æ­¢é‡å¤äº¤æ˜“ã€‚  
  Built-in BloomFilter and LRU strategies to prevent duplicate transactions.
- ğŸŒŠ **å‰Šå³°å¡«è°· (Backpressure)**: å†…å­˜è®¡ç®—å®Œæ¯•åï¼Œé€šè¿‡å¼‚æ­¥æ‰¹é‡æ–¹å¼è½åº“ï¼Œä¿æŠ¤åç«¯æ•°æ®åº“ä¸è¢«æµé‡æ´ªå³°å‡»ç©¿ã€‚  
  Asynchronous batch persistence protects the backend database from traffic spikes.
- ğŸ”Œ **å¼€ç®±å³ç”¨ (Easy Integration)**: æä¾› Spring Boot Starterï¼Œé›¶é…ç½®å³å¯åµŒå…¥ç°æœ‰é¡¹ç›®ï¼Œæ¥å…¥Prometheus + Grafanaã€‚  
  Provides Spring Boot Starter. Just add dependency and config. Integrated with Prometheus + Grafana.
- ğŸ”— **é›†ç¾¤æ”¯æŒ (Cluster Support)**: æ”¯æŒå¤šèŠ‚ç‚¹é›†ç¾¤ï¼Œé€šè¿‡ä¸€è‡´æ€§å“ˆå¸Œå’Œè´Ÿè½½å‡è¡¡å®ç°é«˜å¯ç”¨ã€‚
  Support multi-node cluster. Consistent hashing and load balancing for high availability.

### 1.4 é¡¹ç›®æ¶æ„ / Architecture
#### 1.4.1 æ ¸å¿ƒæ¶æ„ / Core Architecture
```mermaid
graph TD
    User(User Request) -->|HTTP/RPC| Gateway[Wallet Controller]
    
    subgraph "Core Engine (Single Node 100W+ TPS)"
        direction TB
        Gateway -->|1. Append WAL| WAL[(Chronicle WAL)]
        WAL -.->|2. Publish| Disruptor{Disruptor}
        Disruptor -->|3. Consume| Handler[Business Logic]
        
        Handler -- Check --> Idempotency[Bloom/LRU]
        Handler -- Update --> Memory[In-Memory State]
        Memory -.->|Snapshot| Snapshot[(Kryo Snapshot)]
    end

    Handler -->|4. Push| Queue[Async Queue]
    Queue -->|5. Batch Insert| DB_Worker[Batch Writer]
    DB_Worker -->|6. Persist| MySQL[(MySQL/Oracle)]
```
#### 1.4.2 é«˜å¯ç”¨æ¶æ„ / High Availability Architecture
```mermaid
graph TD
    subgraph "External World"
        Client[Client]
    end

    subgraph "Network Layer (ç”¨æˆ·è´Ÿè´£)"
        Gateway[API Gateway / Nginx]
    end

    subgraph "j-atomic-ledger Cluster (3ä¸ªèŠ‚ç‚¹)"
        direction LR
        Node0[LedgerEngine Node 0<br/>node-id=0, total-nodes=3]
        Node1[LedgerEngine Node 1<br/>node-id=1, total-nodes=3]
        Node2[LedgerEngine Node 2<br/>node-id=2, total-nodes=3]
    end

    subgraph "Internal of Node 0"
        direction TB
        Router0["Router (submit)"]
        Checker0["<b style='color:red'>Self-Checker</b><br/>è·¯ç”±æ ¡éªŒ"]
        Partitions0["Partitions<br>(p0, p1, p2, p3)"]
        Router0 --> Checker0
        Checker0 --> Partitions0
    end
    
    %% æµç¨‹
    Client -- Request->userId=100 --> Gateway
    Gateway -- "Hash(100) % 3 = 1" --> Node1
    Gateway -- "Hash(101) % 3 = 2" --> Node2
    Gateway -- "Hash(102) % 3 = 0" --> Node0
    
    Node0 --> Router0
    
    %% æ ·å¼
    classDef highlight fill:#ffcdd2,stroke:#c62828,stroke-width:2px;
    Checker0:::highlight
```
### 1.5 æ¶æ„å¯¹æ¯” / Comparison

| ç»´åº¦ / Dimension               | ç°æœ‰æ¶æ„ (Traditional)                   | **j-atomic-ledger**                                | **æ”¶ç›Š / Benefit**                                            |
|:-----------------------------|:-------------------------------------|:---------------------------------------------------|:------------------------------------------------------------|
| **å¹¶å‘æ¨¡å‹ / Concurrency**       | å¤šçº¿ç¨‹ + æ•°æ®åº“è¡Œé”  Multi-thread + Row Lock | **å•çº¿ç¨‹ + å†…å­˜æ— é”  Single-thread + Lock-free**          | æ— æ­»é”é£é™©ï¼Œæ€§èƒ½çº¿æ€§å¢é•¿  No Deadlocks, Linear Scalability              |
| **æŒä¹…åŒ– / Persistence**        | åŒæ­¥å†™ MySQL  Sync write to DB          | **åŒæ­¥å†™ WAL + å¼‚æ­¥å†™ MySQL  Sync write WAL + Async DB** | I/O å»¶è¿Ÿé™ä½ 1000 å€  I/O Latency reduced by 1000x               |
| **æ•°æ®ä¸€è‡´æ€§ / Consistency**      | å¼ºä¸€è‡´æ€§ (ACID)  Strong (ACID)           | **æœ€ç»ˆä¸€è‡´æ€§ (Base)  Eventual (Base)**                  | ç‰ºç‰²å¾®ç§’çº§å»¶è¿Ÿï¼Œæ¢å–æé«˜å¯ç”¨æ€§  High Availability with Microsecond Latency |
| **å»é‡ä¾èµ– / Idempotency**       | æŸ¥æ•°æ®åº“æˆ–Redis  Database or Redis        | **å†…å­˜è®¡ç®— (Bloom/LRU)  In-Memory Computing**          | 0ç½‘ç»œå¼€é”€  No Network overhead                                  |
| **å•æœº TPS / Single Node TPS** | ~2,000                               | **1,000,000+**                                     | **500 å€æå‡**                                                 |
### 1.6 é€‚ç”¨åœºæ™¯ / Use Cases
1.  **é‡‘èè´¦æˆ·ç³»ç»Ÿ**: é’±åŒ…ä½™é¢æ‰£å‡ã€è½¬è´¦ã€å……å€¼ã€‚
    Financial Systems: Wallet balance updates, transfers. 
2.  **äº¤æ˜“æ’®åˆå¼•æ“**: è‚¡ç¥¨ã€åŠ å¯†è´§å¸ã€NFT äº¤æ˜“æ’®åˆã€‚
    Matching Engine: Stock, Crypto trading. 
3.  **ç”µå•†ç§’æ€ä¸­å¿ƒ**: é«˜å¹¶å‘åº“å­˜æ‰£å‡ï¼ˆé˜²è¶…å–ï¼‰ã€‚
    Flash Sales: Inventory deduction. 
4.  **æ¸¸æˆç»æµç³»ç»Ÿ**: é“å…·å‘æ”¾ã€é‡‘å¸æµè½¬ã€ç§¯åˆ†ç»“ç®—ã€‚
    Game Economy: Item/Gold distribution. 
5.  **ç‰©è”ç½‘è®¾å¤‡ç®¡ç†**: è®¾å¤‡çŠ¶æ€å˜æ›´ã€æ•°æ®ä¸ŠæŠ¥ã€äº‹ä»¶å¤„ç†ã€‚
    IoT Management: Device state changes, data reporting.
6.  **IDç”Ÿæˆç³»ç»Ÿ**: é«˜å¹¶å‘ä¸‹é«˜æ•ˆã€å”¯ä¸€ã€ç»å¯¹æœ‰åºçš„ ID ç”Ÿæˆã€‚
    ID Generation: Efficient, unique, absolutely ordered IDs.

---

## ğŸš€ 2. Quick Start / å¿«é€Ÿå¼€å§‹
#### å¯ä»¥æ‰“å¼€ j-atomic-ledger-example é¡¹ç›®ï¼ŒæŸ¥çœ‹å®Œæ•´ç¤ºä¾‹ä»£ç ã€‚
### 2.1 å¼•å…¥ä¾èµ– / Add Dependency
```xml
<dependency>
    <groupId>io.github.vevoly</groupId>
    <artifactId>j-atomic-ledger-spring-boot-starter</artifactId>
    <version>1.1.0</version>
</dependency>
```
### 2.2 é…ç½®æ–‡ä»¶ / Configuration (application.yml)
```yaml
j-atomic-ledger:
  base-dir: ./data/ledger-data # æ•°æ®å­˜å‚¨è·¯å¾„ / Data storage path
  engine-name: wallet-core     # å¼•æ“åç§° / Engine name
  metrics-prefix: wallet       # metrics å‰ç¼€ / Metrics prefix
  partitions: 4                # åˆ†ç‰‡æ•°é‡ / Number of partitions
  queue-size: 65536            # å¼‚æ­¥è½åº“é˜Ÿåˆ— / Async DB queue size
  snapshot-interval: 50000     # å¤šå°‘æ¡åšä¸€æ¬¡å¿«ç…§ / How many records to snapshot
  enable-time-snapshot: true   # å¼€å¯æ—¶é—´å¿«ç…§ / Enable time-based snapshot
  snapshot-time-interval: 10m  # å¤šå°‘æ—¶é—´ä¿å­˜ä¸€æ¬¡å¿«ç…§ï¼Œæ”¯æŒ msã€sã€mã€hã€d å•ä½ / How often to save a snapshot, supports ms, s, m, h, d units
  batch-size: 1000             # æ‰¹é‡è½åº“å¤§å° / DB batch insert size
  idempotency: BLOOM           # å»é‡ç­–ç•¥ï¼šBLOOM or LRU / Idempotency strategy: BLOOM or LRU
  routing: RENDEZVOUS          # é›†ç¾¤è·¯ç”±å’ŒèŠ‚ç‚¹å†…åˆ†ç‰‡è·¯ç”±ç­–ç•¥ / Cluster routing and internal sharding routing strategy
  cluster:                     # é›†ç¾¤é…ç½® / Cluster configuration
    total-nodes: 1             # é›†ç¾¤èŠ‚ç‚¹æ€»æ•° / Total number of cluster nodes
    node-id: 0                 # å½“å‰èŠ‚ç‚¹ ID / Current node ID
```

### 2.3 æ ¸å¿ƒå®ç° / Core Implementation
#### 2.3.1 å®šä¹‰å†…å­˜çŠ¶æ€å’Œå‘½ä»¤å¯¹è±¡ / Define Memory State and Command Object
```java
// 1. å®šä¹‰ä½ çš„å†…å­˜çŠ¶æ€å¯¹è±¡ / Define your memory state (POJO)
@Data
public class WalletState implements Serializable {
    // ä½™é¢ç±»å‹ä¸ºlongï¼ˆå˜ï¼‰/ Store balance as 'long' (cents) for best performance
    private Map<Long, Long> balances = new HashMap<>();

    // Mapé‡Œå¯ä»¥æ˜¯ WalletDomain å¯¹è±¡ï¼Œæ£€æŸ¥é’±åŒ…çŠ¶æ€ / Map can be WalletDomain object, check wallet status
//    private Map<Long, WalletDomain> wallets = new HashMap<>();
}

// 2. ç»§æ‰¿BaseLedgerCommandç±»ï¼Œå®šä¹‰ä½ çš„äº¤æ˜“å‘½ä»¤ / Inherit BaseLedgerCommand, define your trade command
@Data
@EqualsAndHashCode(callSuper = true)
public class TradeCommand extends BaseLedgerCommand {

    /**
     * ä¸šåŠ¡å­—æ®µï¼šç”¨æˆ·ID.
     * Business Field: User ID.
     */
    private Long userId;

    // txId å’Œ amount å­—æ®µå·²åœ¨çˆ¶ç±»å®šä¹‰ï¼Œæ­¤å¤„æ— éœ€é‡å¤å®šä¹‰
    // txId and amount fields are defined in the parent class and do not need to be redefined here.

    /**
     * å®šä¹‰åˆ†ç‰‡è·¯ç”±è§„åˆ™.
     * Define the sharding routing rule.
     * @return è¿”å› userId çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œç¡®ä¿åŒä¸€ç”¨æˆ·çš„è¯·æ±‚è¿›å…¥åŒä¸€ä¸ª Disruptor çº¿ç¨‹
     * Return userId as a string to ensure that requests from the same user enter the same Disruptor thread.
     */
    @Override
    public String getRoutingKey() {
        return String.valueOf(userId);
    }

    /**
     * åºåˆ—åŒ–æ‰©å±•ï¼šå†™å…¥ä¸šåŠ¡å­—æ®µ. / Serialization Extension: Write business fields.
     * <p>çˆ¶ç±»å·²å¤„ç† txId å’Œ amount / txId and amount fields are handled in the parent class </p>
     */
    @Override
    protected void writeBizData(BytesOut<?> bytes) {
        bytes.writeLong(userId);
    }

    /**
     * ååºåˆ—åŒ–æ‰©å±•ï¼šè¯»å–ä¸šåŠ¡å­—æ®µ. / Deserialization Extension: Read business fields
     * <p>è¯»å–é¡ºåºå¿…é¡»ä¸å†™å…¥é¡ºåºä¸¥æ ¼ä¸€è‡´ï¼/ Must match write order!</p>
     */
    @Override
    protected void readBizData(BytesIn<?> bytes) {
        this.userId = bytes.readLong();
    }
}
```
#### 2.3.2 å®šä¹‰ä¸šåŠ¡å¤„ç†é€»è¾‘ / Define Business Logic
```java
@Component
public class WalletProcessor implements BusinessProcessor<WalletState, TradeCommand, WalletEntity> {
    @Override
    public WalletEntity process(WalletState state, TradeCommand cmd) {
        long start = System.nanoTime();
        // 1. ä¸šåŠ¡é€»è¾‘ï¼šè·å–ä½™é¢ / Business logic: Get balance
        long currentBalance = state.getBalances().getOrDefault(cmd.getUserId(), 0L);
        // 2. ä¸šåŠ¡é€»è¾‘ï¼šæ£€æŸ¥ä½™é¢ (ä»…æ‰£æ¬¾æ—¶) / Business Logic: Check balance (Only for debit)
        if (cmd.getAmount() < 0 && currentBalance + cmd.getAmount() < 0) {
            // ç›´æ¥æŠ›å¼‚å¸¸ï¼Œæ¡†æ¶ä¼šæ•è·å¹¶ä¼ é€’ç»™ CompletableFuture
            // Throw exception directly, framework will catch and pass to CompletableFuture
            throw new RuntimeException("ä½™é¢ä¸è¶³ / Insufficient Balance");
        }
        // 3. ä¿®æ”¹å†…å­˜çŠ¶æ€ / Mutate Memory State
        long newBalance = currentBalance + cmd.getAmount();
        state.getBalances().put(cmd.getUserId(), newBalance);
        // 2. è¿”å›å¢é‡å®ä½“ / Return Incremental Entity
        UserWalletEntity entity = new UserWalletEntity();
        entity.setUserId(cmd.getUserId());
        entity.setBalance(MoneyUtils.toDb(newBalance));
        // 4. ä¸»åŠ¨é€šçŸ¥ Futureï¼Œè¿”å›ç»“æœå¯¹è±¡ / Notify Future, Return Result Object
        if (cmd.getFuture() != null) {
            TradeResult result = TradeResult.success(cmd.getUserId(), cmd.getTxId(), MoneyUtils.toDb(newBalance));
            result.setLatencyNs(System.nanoTime() - start);
            // å¡«å…¥ç»“æœ / Fill in the result
            cmd.getFuture().complete(result);
        }
        return entity;
    }
}
```
#### 2.3.3 å®šä¹‰å¼‚æ­¥è½åº“é€»è¾‘ / Define Asynchronous Database Logic
```java
@Component
public class WalletSyncer implements BatchWriter<WalletEntity> {
    
    @Autowired
    private MockWalletMapper walletMapper;
    
    @Override
    public void persist(List<WalletEntity> entities) {
        // 1. ä¼˜å…ˆå†™å…¥æ•°æ®åº“ (å½’æ¡£/å…œåº•) / Write to DB first (Archival/Backup)
        walletMapper.batchUpdate(entities);
        // 2. åŒæ­¥æ›´æ–° Redis (è¯»è§†å›¾) / Sync update Redis (Read View)
    }
}
```
#### 2.3.4 å®šä¹‰å¯åŠ¨å¼•å¯¼ / Define Bootstrapping
```java
@Component
public class WalletBootstrap implements LedgerBootstrap<WalletState, TradeCommand> {
    @Override
    public WalletState getInitialState() { 
        // é€šå¸¸åœ¨æ­¤å¤„è°ƒç”¨æ•°æ®åº“ DAOï¼ŒåŠ è½½æ‰€æœ‰ç”¨æˆ·çš„ä½™é¢åˆ°å†…å­˜ä¸­ï¼ˆæ•°æ®é¢„çƒ­ï¼‰
        // Usually call the database DAO here to load all user balances into memory (data preheating)
        return new WalletState(); 
    }
    // è·å–å‘½ä»¤ç±»çš„ Class å¯¹è±¡ (Get Command Class Type)
    @Override
    public Class<TradeCommand> getCommandClass() {
        // å‘Šè¯‰å¼•æ“ååºåˆ—åŒ–ç”¨è¿™ä¸ªç±» / Tell the engine to deserialize with this class
        return TradeCommand.class; 
    }
}
```
### 2.4 è°ƒç”¨ / Usage
#### æ³¨å…¥è´¦æœ¬å¼•æ“å¹¶å¯åŠ¨ / Inject Ledger Engine and Start
> æ›´å¤šé«˜çº§ç”¨æ³•è¯·æŸ¥çœ‹ j-atomic-ledger-example æ¨¡å—ä¸­çš„ api/BenchController ç±»  
> For more advanced usage, please refer to the api/BenchController class in the j-atomic-ledger-example module
```java
@Autowired
private LedgerEngine<WalletState, TradeCommand, WalletEntity> engine;

public void trade(long uid, long amount) {
    TradeCommand cmd = new TradeCommand();
    cmd.setTxId(UUID.randomUUID().toString());
    cmd.setUserId(uid);
    cmd.setAmount(amount);
    // Fire and Forget (or use setFuture for sync result)
    engine.submit(cmd);
}
```
### 2.5 ä½¿ç”¨ WAL æ—¥å¿—æŸ¥çœ‹å™¨å’Œå¿«ç…§æŸ¥çœ‹å™¨ / Use WAL Log Viewer and Snapshot Viewer

---
## ğŸ“– 3. ä½¿ç”¨æŒ‡å— / User Guide
### 3.1 å¼€å‘è§„èŒƒä¸ç”¨æˆ·å¥‘çº¦ / Development Contracts and User Contract
ä¸ºäº†ç¡®ä¿æè‡´æ€§èƒ½ä¸æ•°æ®å®‰å…¨ï¼Œç”¨æˆ·éœ€éµå¾ªä»¥ä¸‹å¥‘çº¦ï¼š  
To ensure high performance and safety, users must follow these rules:
1. **å¼ºåˆ¶ä½¿ç”¨ `long` é‡‘é¢**ï¼šä¸¥ç¦åœ¨ `TradeCommand` ä¸­ä½¿ç”¨ `BigDecimal`ã€‚è¯·åœ¨å…¥å£å¤„å°†é‡‘é¢è½¬æ¢ä¸ºæœ€å°å•ä½ï¼ˆå¦‚ï¼šå˜ï¼‰ã€‚  
   **Strictly use `long` for amounts**: Never use `BigDecimal` in `TradeCommand`. Convert amounts to atomic units (e.g., cents) at the entrance.
2. **Future å¿…é¡»æ ‡è®°ä¸º `transient`**ï¼šé˜²æ­¢ WAL å†™å…¥æ—¶åºåˆ—åŒ–å¤±è´¥ã€‚
   **Mark Future as `transient`**: The `CompletableFuture` field in Command must be `transient` to avoid serialization errors during WAL writing.
3. **Processor ç¦æ­¢ I/O**ï¼šä¸šåŠ¡é€»è¾‘è¿è¡Œåœ¨å•çº¿ç¨‹ä¸­ï¼Œä¸¥ç¦æŸ¥åº“æˆ–è¿œç¨‹è°ƒç”¨ï¼Œå¦åˆ™ååé‡ä¼šç¬é—´å´©å¡Œã€‚   
   **No I/O in Processor**: The `process()` method runs in a single thread. **Do NOT** perform any Database/Redis/Network I/O here, or the throughput will collapse. 
4. **é›†ç¾¤éƒ¨ç½²å¿…é¡»ä½¿ç”¨å’Œå¼•æ“å†…ç›¸åŒçš„è·¯ç”±ç­–ç•¥**ï¼Œå¦åˆ™å¼•æ“å†…é›†ç¾¤è·¯ç”±æ ¡éªŒå°†ä¸ä¼šé€šè¿‡ã€‚é›†ç¾¤å»ºè®®ä½¿ç”¨ Rendezvous ç­–ç•¥ï¼Œä¾¿äºé›†ç¾¤æ‰©å®¹ã€‚
   **Cluster deployment must use the same routing strategy as the engine**, otherwise the cluster routing validation will fail. For clusters, it is recommended to use the Rendezvous strategy for easier scaling.
### 3.2 Java 17+ JVM é…ç½® (Chronicle) / Chronicle Configuration
ç”±äº Java 17+ çš„æ¨¡å—åŒ–é™åˆ¶ï¼ŒChronicle Queue éœ€è¦è®¿é—®åº•å±‚ APIã€‚æœ¬åœ°å¼€å‘å·¥å…·å¯åŠ¨éœ€æ·»åŠ VMé€‰é¡¹ï¼Œç”Ÿäº§ç¯å¢ƒå¯åŠ¨æ—¶**å¿…é¡»**æ·»åŠ ä»¥ä¸‹ JVM å‚æ•°ï¼Œå¦åˆ™ä¼šæŠ¥é”™æˆ–æ€§èƒ½ä¸‹é™:  
Since Java 17+, strong encapsulation requires specific JVM flags to allow Chronicle Queue to access low-level APIs (Direct Memory/Unsafe). Add these to your startup script:
```bash
--add-exports=java.base/jdk.internal.ref=ALL-UNNAMED
--add-exports=java.base/sun.nio.ch=ALL-UNNAMED
--add-exports=jdk.unsupported/sun.misc=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED
--add-opens=jdk.compiler/com.sun.tools.javac=ALL-UNNAMED
--add-opens=java.base/java.lang=ALL-UNNAMED
--add-opens=java.base/java.lang.reflect=ALL-UNNAMED
--add-opens=java.base/java.io=ALL-UNNAMED
--add-opens=java.base/java.util=ALL-UNNAMED
```
### 3.3 å»é‡ç­–ç•¥ / Idempotency Strategy
åœ¨é…ç½®æ–‡ä»¶ä¸­é€‰æ‹©ç­–ç•¥ / Configure in application.yml:
> * BLOOM (Default)  
å¸ƒéš†è¿‡æ»¤å™¨ï¼Œé«˜æ€§èƒ½ï¼Œæä½å†…å­˜(1åƒä¸‡æ¡è®°å½•ä»…10MB)ã€‚é€‚åˆæµ·é‡æ•°æ®å»é‡ã€‚  
High performance, low memory (10MB for 10M records). Tiny false-positive rate. Best for massive data.
> * LRU: idempotency: LRU 
100% å‡†ç¡®ï¼Œä½†å†…å­˜å ç”¨è¾ƒé«˜ã€‚é€‚åˆåªéœ€å¯¹æœ€è¿‘äº¤æ˜“å»é‡çš„åœºæ™¯ã€‚  
100% accurate. Higher memory usage. Suitable for scenarios requiring strict recent deduplication.

### 3.4 è·å–å¼‚æ­¥ç»“æœ / Get async result
> * åŒæ­¥æ¨¡å¼ï¼šå‘ Command ä¼ å…¥ Futureï¼ŒController é˜»å¡ç­‰å¾…ç»“æœã€‚  
    Sync Mode (Standard): Pass a CompletableFuture into the command. The controller waits for future.get().
> * æé€Ÿæ¨¡å¼ï¼šå‘ Command ä¼ å…¥ nullã€‚å¼•æ“è·³è¿‡é€šçŸ¥é€»è¾‘ï¼Œè·å¾—ç‰©ç†æé™ååé‡ã€‚  
    Fire-and-Forget (Extreme): Pass null as future. The engine skips notification overhead, achieving maximum TPS.
### 3.5 é›†ç¾¤éƒ¨ç½² / Cluster Deployment
#### j-atomic-ledger æ˜¯æœ‰çŠ¶æ€å¼•æ“ï¼Œæ­£ç¡®çš„é›†ç¾¤é…ç½®å¯¹äºé˜²æ­¢æ•°æ®é”™ä¹±è‡³å…³é‡è¦ã€‚j-atomic-ledger is a Stateful engine, correct cluster configuration is crucial to prevent data corruption. 
>âš ï¸ é‡è¦æç¤º / Important
é›†ç¾¤éƒ¨ç½²æ—¶ï¼Œå¿…é¡»é…ç½®ä¸Šæ¸¸è´Ÿè½½å‡è¡¡å™¨ï¼ˆNginx/Gatewayï¼‰ä½¿ç”¨åŸºäº RoutingKey çš„ä¸€è‡´æ€§å“ˆå¸Œç­–ç•¥ã€‚æˆ‘ä»¬å¼ºçƒˆæ¨èä½¿ç”¨ Rendezvous Hashing (é›†åˆç‚¹å“ˆå¸Œ)ã€‚ä½¿ç”¨è½®è¯¢ï¼ˆRound Robinï¼‰å°†å¯¼è‡´æ•°æ®é”™ä¹±ã€‚  
For cluster deployment, you MUST configure your upstream load balancer (Nginx/Gateway) to use a Consistent Hashing strategy based on the RoutingKey (e.g., userId). We strongly recommend using Rendezvous Hashing. Using Round Robin will lead to data corruption.
1. åˆ†ç‰‡åŸåˆ™ / Sharding Principle 
> åŒä¸€ä¸ªä¸šåŠ¡å®ä½“ï¼ˆå¦‚ userIdï¼‰çš„è¯·æ±‚å¿…é¡»æ°¸è¿œè¢«è·¯ç”±åˆ°åŒä¸€ä¸ªæœåŠ¡èŠ‚ç‚¹ã€‚è¿™æ˜¯é€šè¿‡å¯¹ RoutingKey è¿›è¡Œå“ˆå¸Œè®¡ç®—å®ç°çš„ã€‚  
  Requests for the same business entity (e.g., userId) must always be routed to the same service node. This is achieved by hashing the RoutingKey.
2. èŠ‚ç‚¹é…ç½® / Configuration  (application.yml)
> é›†ç¾¤ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½å¿…é¡»æœ‰å”¯ä¸€çš„ node-idã€‚   
  Each node in the cluster must have a unique node-id.
```yaml
# Node 0:
j-atomic-ledger:
  cluster:
    total-nodes: 3  # Total nodes in the cluster
    node-id: 0      # This is node 0
```
```yaml
# Node 1:
j-atomic-ledger:
  cluster:
    total-nodes: 3
    node-id: 1
```
3. è·¯ç”±ç­–ç•¥ / Routing Strategy
> * é›†ç¾¤è·¯ç”±ç­–ç•¥å’Œå¼•æ“å†…éƒ¨è·¯ç”±ç­–ç•¥å¿…é¡»ä¸€è‡´ï¼Œå¦åˆ™å°†æ— æ³•é€šè¿‡èŠ‚ç‚¹æ ¡éªŒã€‚  
    Cluster routing strategy and engine internal routing strategy must be consistent, otherwise node verification will fail.
> * ç›®å‰å¼•æ“å®ç°2ç§è·¯ç”±ç­–ç•¥ï¼š
>   * é›†åˆç‚¹å“ˆå¸Œï¼šRendezvous Hashing  
      è´Ÿè½½å‡è¡¡æ€§æä½³ï¼Œä¸”åœ¨æ‰©å®¹/ç¼©å®¹æ—¶ï¼Œåªéœ€è¿ç§»æå°‘é‡æ•°æ®ï¼Œè¿ç»´å‹å¥½ï¼Œé€‚åˆé›†ç¾¤æ¨¡å¼ã€‚  
      Excellent load balancing and minimal data migration on resizing. suitable for Cluster.
>   * å–æ¨¡å“ˆå¸Œï¼šModulo Hashing  
      å®ç°ç®€å•ï¼Œè®¡ç®—é€Ÿåº¦æå¿«ï¼Œä½†å½“èŠ‚ç‚¹æ•°å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå‡ ä¹æ‰€æœ‰ Key çš„è·¯ç”±éƒ½ä¼šå¤±æ•ˆï¼Œå¯¼è‡´æ•°æ®éœ€è¦å…¨é‡è¿ç§»ã€‚  
      Simple and fast, But when the number of nodes changes, almost all keys will be routed to a different partition, requiring full data migration.
> * ç”¨æˆ·æ‰©å±•è·¯ç”±ç­–ç•¥ / Extend the routing strategy  
    é€šè¿‡å®šä¹‰ä¸€ä¸ª Spring `@Bean` æ¥æä¾›è‡ªå·±çš„ `RoutingStrategy` æˆ– `IdempotencyStrategy` å®ç°ã€‚Starter ä¼šè‡ªåŠ¨æ£€æµ‹å¹¶ä½¿ç”¨æ‚¨çš„è‡ªå®šä¹‰ Beanï¼Œè¦†ç›–é»˜è®¤é…ç½®ã€‚  
    You can provide your own implementation for `RoutingStrategy` or `IdempotencyStrategy` by simply defining it as a Spring `@Bean`. The starter will automatically detect and use your custom bean, overriding the default one.
>   * ä¸€æ—¦ä½¿ç”¨äº†è‡ªå®šä¹‰ç­–ç•¥ï¼Œé…ç½®æ–‡ä»¶ä¸­çš„é…ç½®å°†è‡ªåŠ¨å¤±æ•ˆã€‚  
    Once a custom strategy is used, the configuration in the configuration file will be automatically invalidated
>   * ç”¨æ³•è¯·å‚è€ƒ j-atomic-ledger-example æ¨¡å—ä¸­çš„ config/CustomStrategyConfig ç±»ã€‚  
    For more information, please refer to the CustomStrategyConfig class in the j-atomic-ledger-example module.

4. è´Ÿè½½å‡è¡¡å™¨é…ç½® / Load Balancer Configuration (Nginx/Gateway)
> é›†ç¾¤çš„è´Ÿè½½å‡è¡¡å™¨å¿…é¡»é…ç½®åŸºäº RoutingKey çš„ä¸€è‡´æ€§å“ˆå¸Œç­–ç•¥ã€‚è½®è¯¢ï¼ˆRound Robinï¼‰å°†å¯¼è‡´æ•°æ®é”™ä¹±ã€‚å¯¹æ­¤ä½œè€…æ¨èä½¿ç”¨ Rendezvous Hashing (é›†åˆç‚¹å“ˆå¸Œ) ç®—æ³•ã€‚  
The load balancer of the cluster must be configured with a Consistent Hashing strategy based on the RoutingKey. Round Robin will lead to data corruption. We strongly recommend using Rendezvous Hashing algorithm.
```yaml
# nginx.conf
http {
    # Define upstream servers for each node
    upstream ledger_node_0 { server 192.168.1.100:8080; }
    upstream ledger_node_1 { server 192.168.1.101:8080; }
    upstream ledger_node_2 { server 192.168.1.102:8080; }

    server {
        location / {
            content_by_lua_block {
                local chash = require "resty.chash"
                
                -- Get routing key from request (e.g., URL param 'userId')
                local key = ngx.var.arg_userId
                if not key then
                    ngx.exit(400)
                    return
                end

                local nodes = {"ledger_node_0", "ledger_node_1", "ledger_node_2"}
                
                -- Get target node using Rendezvous Hashing
                local target_node = chash.hrw(key, nodes)
                
                ngx.exec("@" .. target_node)
            }
        }
        
        location @ledger_node_0 { proxy_pass http://ledger_node_0; }
        location @ledger_node_1 { proxy_pass http://ledger_node_1; }
        location @ledger_node_2 { proxy_pass http://ledger_node_2; }
    }
}
```

5. æ‰©å®¹ / Scaling 
>  æ•¬è¯·æœŸå¾… v2.0 ç‰ˆæœ¬ / Coming soon in v2.0
### 3.6 ç›‘æ§
å¼€å¯ Actuator ä»¥æŸ¥çœ‹æ ¸å¿ƒæŒ‡æ ‡ / Enable Spring Boot Actuator to view Micrometer metrics:  
> * j-atomic-ledger.ring.remaining: æ ¸å¿ƒé£é™©æŒ‡æ ‡ï¼Œæ¥è¿‘0è¯´æ˜å¤„ç†ä¸è¿‡æ¥ã€‚  
  Core Risk Indicator. If close to 0, consumption is too slow. ()
> * j-atomic-ledger.db.queue.size: èƒŒå‹æŒ‡æ ‡ï¼Œå †ç§¯è¯´æ˜æ•°æ®åº“æ…¢ã€‚  
  Backpressure Indicator. If high, the database is the bottleneck. 
> * j-atomic-ledger.db.batch.time: æ•°æ®åº“å†™å…¥è€—æ—¶ã€‚Database write latency. 
### 3.7 å±è”½ Chronicle å™ªéŸ³ / Disable Chronicle noise
 * å±è”½Info çº§åˆ«å™ªéŸ³ / Disable Chronicle Info level noise
 ``` yaml
logging:
  level:
    root: INFO
    # å±è”½ Chronicle çš„ INFO çº§åˆ«å™ªéŸ³ï¼ˆæ¯”å¦‚ç£ç›˜æ£€æŸ¥ã€æ˜ å°„æ–‡ä»¶æ‰©å®¹æ—¥å¿—ï¼‰
    # Disable Chronicle's INFO level noise (e.g. disk checks, mapped file expansion logs)
    net.openhft: WARN
 ```
 * ç¦ç”¨ Chronicle çš„ Google Analytics ä¸ŠæŠ¥ / Disable Chronicle's Google Analytics reporting
```java
 @SpringBootApplication
public class WalletApplication {
    public static void main(String[] args) {
        // ç¦ç”¨ Chronicle çš„ Google Analytics ä¸ŠæŠ¥
        // Disable Chronicle's Google Analytics reporting
        System.setProperty("chronicle.analytics.disable", "true");
        SpringApplication.run(WalletApplication.class, args);
    }
}
 ```
### 3.8 é«˜æ€§èƒ½è¯»è§†å›¾ / High performance read view

---
## â“ 4. å¸¸è§é—®é¢˜ / FAQ 
### 4.1 å®•æœºäº†æ•°æ®ä¼šä¸¢å¤±å—ï¼Ÿ / Is data lost when the server crashes?
ä¸ä¼šã€‚ æ‰€æœ‰æŒ‡ä»¤åœ¨å¤„ç†å‰éƒ½ä¼šé€šè¿‡å†…å­˜æ˜ å°„å†™å…¥ç£ç›˜ WALã€‚é‡å¯æ—¶ï¼Œå¼•æ“ä¼šè‡ªåŠ¨é‡æ”¾æ—¥å¿—ï¼Œæ•°æ®é›¶ä¸¢å¤±ã€‚    
No. Every command is written to the WAL (Write-Ahead Log) on disk using memory mapping before processing. On restart, the engine automatically replays the WAL to restore the memory state.
### 4.2 æ•°æ®åº“æŒ‚äº†æ€ä¹ˆåŠï¼Ÿ / What if the DB is dead?
ä¸šåŠ¡ä¸å—å½±å“ã€‚ å¼•æ“ä¾ç„¶å¯ä»¥æ¥å•å’Œè®¡ç®—ã€‚æ•°æ®ä¼šå †ç§¯åœ¨å¼‚æ­¥é˜Ÿåˆ—ä¸­ã€‚åå°çº¿ç¨‹ä¼šæ— é™é‡è¯•ï¼Œç›´åˆ°æ•°æ®åº“æ¢å¤ï¼Œè‡ªåŠ¨å°†ç§¯å‹æ•°æ®å†™å…¥ã€‚  
The engine will continue to process requests in memory. Data waiting for persistence will pile up in the AsyncQueue. The BatchWriter will retry indefinitely until the DB recovers.
### 4.3 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨WALï¼Ÿ / Why use WAL?
æ•°æ®åº“äº‹åŠ¡æ¶‰åŠéšæœº I/O å’Œé”ç«äº‰ï¼ˆæ¯«ç§’çº§ï¼‰ã€‚WAL é‡‡ç”¨é¡ºåºè¿½åŠ å†™ï¼Œé€Ÿåº¦åª²ç¾å†…å­˜ï¼ˆçº³ç§’çº§ï¼‰ã€‚è¿™æ˜¯å®ç°ç™¾ä¸‡ TPS çš„ç§˜è¯€ã€‚  
Database transactions involve random I/O and locks (ms level). WAL uses Sequential Write (append-only), which is as fast as memory (ns level). This is the secret to 1 million TPS.
### 4.4 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨Kryoåºåˆ—åŒ–? / Why use Kryo serialization?
Java åŸç”Ÿåºåˆ—åŒ–æ•ˆç‡ä½ä¸”ä½“ç§¯å¤§ã€‚Kryo ç”Ÿæˆçš„äºŒè¿›åˆ¶æå…¶ç´§å‡‘ï¼Œèƒ½æå¤§é™ä½ IO å¼€é”€ï¼Œå®ç°ç§’çº§å¯åŠ¨æ¢å¤ã€‚  
Java native serialization is slow and verbose. Kryo produces extremely compact binary data, reducing IO overhead and enabling Second-level Startup/Recovery.
### 4.5 ä¸ºä»€ä¹ˆå†…å­˜è®¡ç®—å¿…é¡»ä½¿ç”¨longï¼Ÿ / Why must memory calculation use long?
BigDecimal æ˜¯å¯¹è±¡ï¼Œä¼šäº§ç”Ÿå¤§é‡ GC å‹åŠ›ã€‚long æ˜¯ CPU åŸç”Ÿç±»å‹ã€‚åœ¨é«˜é¢‘äº¤æ˜“åœºæ™¯ä¸‹ï¼Œé›¶ GC å¯¹äºä¿æŒä½å»¶è¿Ÿè‡³å…³é‡è¦ã€‚  
BigDecimal creates objects, causing GC (Garbage Collection) pressure. long is a primitive type handled directly by the CPU. In high-frequency trading, Zero-GC is crucial for stable latency.
### 4.3 éé‡‘èç³»ç»Ÿèƒ½ç”¨å—ï¼Ÿ / Can it be used in non-financial systems?
å®Œå…¨å¯ä»¥ã€‚ ä»»ä½•éœ€è¦â€œä¸¥æ ¼é¡ºåºâ€å’Œâ€œé«˜ååâ€çš„åœºæ™¯éƒ½é€‚ç”¨ï¼Œä¾‹å¦‚ IM æ¶ˆæ¯ ID ç”Ÿæˆã€ç§’æ€åº“å­˜æ‰£å‡ã€å…¨å±€ç²¾å‡†é™æµ ç­‰ã€‚  
Yes. It is perfect for any scenario requiring "Strict Sequencing" and "High Throughput", such as:
IM Generation: Generating strictly increasing message IDs for chat groups.
Inventory: Flash sale inventory deduction.
Rate Limiting: Global precise sliding window counters.
### 4.4 å¦‚ä½•ä¿è¯â€œå†…å­˜è®¡ç®—ã€æ•°æ®åº“ä¿®æ”¹ã€è´¦å˜è®°å½•â€çš„äº‹åŠ¡æ€§ï¼Ÿ / How to ensure the transactionality of "memory calculation, database modification, and account change record"?
LMAX æ¶æ„é‡æ–°å®šä¹‰äº†â€œäº‹åŠ¡â€ã€‚åœ¨ä¼ ç»Ÿæ¶æ„ä¸­ï¼Œäº‹åŠ¡ = BEGIN TRANSACTION ... COMMITã€‚
è€Œåœ¨ j-atomic-ledger ä¸­ï¼Œäº‹åŠ¡ = â€œä¸€ä¸ªä¸å¯åˆ†å‰²çš„ã€å·²è½ç›˜çš„äº‹ä»¶ï¼ˆCommandï¼‰â€ã€‚æˆ‘ä»¬é€šè¿‡3é“é˜²çº¿æ¥ä¿è¯åŸå­æ€§ï¼š
1. å•çº¿ç¨‹å¤„ç† (Effective Atomicity)
 * æœºåˆ¶ï¼šDisruptor ä¿è¯äº†å¯¹äºåŒä¸€ä¸ªç”¨æˆ·ï¼ˆåŒä¸€ä¸ªåˆ†ç‰‡ï¼‰ï¼Œæ‰€æœ‰çš„ Command éƒ½æ˜¯åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œä¸²è¡Œæ‰§è¡Œçš„ã€‚
 * æ•ˆæœï¼šå½“ process æ–¹æ³•æ‰§è¡Œæ—¶ï¼Œæ²¡æœ‰å…¶ä»–çº¿ç¨‹ä¼šæ¥äº‰æŠ¢è¿™ä¸ªç”¨æˆ·çš„å†…å­˜æ•°æ®ã€‚
   * state.balance += amount;
   * E entity = new WalletEntity(...); (æ„å»ºè´¦å˜è®°å½•)
   * è¿™ä¸¤è¡Œä»£ç åœ¨å•çº¿ç¨‹ä¸­å°±æ˜¯**â€œäº‹å®ä¸Šçš„åŸå­æ“ä½œâ€**ï¼Œç»ä¸ä¼šå‡ºç°â€œä½™é¢æ”¹äº†ä½†è®°å½•æ²¡ç”Ÿæˆâ€çš„æƒ…å†µã€‚
2. WAL é¢„å†™æ—¥å¿— (Durability & Rollback Safety)
 * æœºåˆ¶ï¼šåœ¨æ‰§è¡Œ process ä¹‹å‰ï¼ŒCoreEventHandler å·²ç»æŠŠ TradeCommand å†™å…¥äº†æœ¬åœ° WAL æ–‡ä»¶ã€‚è¿™æ˜¯çœŸæ­£çš„â€œCommit Pointâ€ã€‚
 * æ•ˆæœï¼š
   * æƒ…å†µ Aï¼šprocess æ‰§è¡Œå¤±è´¥ (æ¯”å¦‚ RuntimeException: ä½™é¢ä¸è¶³)ã€‚
     * å†…å­˜ state æ²¡æœ‰è¢«ä¿®æ”¹ã€‚
     * å¼‚æ­¥è½åº“é˜Ÿåˆ—æ²¡æœ‰æ”¶åˆ°æ–°çš„ Entityã€‚
     * WAL é‡Œè®°å½•äº†è¿™æ¬¡â€œå¤±è´¥çš„å°è¯•â€ï¼Œå¯ä¾›å®¡è®¡ã€‚
     * ç»“æœï¼šç³»ç»ŸçŠ¶æ€ä¿æŒä¸€è‡´ã€‚
   * æƒ…å†µ Bï¼šå†™å®Œ WAL åï¼ŒæœåŠ¡å™¨æ–­ç”µã€‚
     * å†…å­˜ state ä¸¢å¤±ã€‚
     * é‡å¯åï¼šrecover() è¿‡ç¨‹ä¼šé‡æ”¾è¿™æ¡ WAL è®°å½•ï¼Œé‡æ–°æ‰§è¡Œ processï¼ŒæŠŠæ–­ç”µå‰æ²¡å®Œæˆçš„æ“ä½œè¡¥ä¸Šã€‚
     * ç»“æœï¼šç³»ç»Ÿè‡ªæ„ˆåˆ°ä¸€è‡´çŠ¶æ€ã€‚
3. å¼‚æ­¥è½åº“çš„æ— é™é‡è¯• (Async write DB and retry infinitely)
 * æœºåˆ¶ï¼šAsyncWriter å†…éƒ¨æœ‰ while(!success) å¾ªç¯ã€‚
 * æ•ˆæœï¼š
   * process æˆåŠŸåï¼ŒEntity è¢«æ”¾å…¥äº†è½åº“é˜Ÿåˆ—ã€‚
   * å¦‚æœæ­¤æ—¶æ•°æ®åº“æŒ‚äº†ï¼ŒAsyncWriter ä¼šå¡åœ¨é‚£é‡Œæ­»å¾ªç¯é‡è¯•ï¼Œç›´åˆ°æ•°æ®åº“æ¢å¤ã€‚
   * ç»“æœï¼šä¿è¯äº†å†…å­˜çš„å˜æ›´æœ€ç»ˆä¸€å®šä¼šåŒæ­¥åˆ°æ•°æ®åº“ã€‚
### 4.5 ç”¨ Redis èƒ½åšåˆ°è·Ÿæˆ‘ä»¬åŸå­è´¦æœ¬ä¸€æ ·çš„åŠŸèƒ½å—ï¼Ÿ / Can Redis do the same thing as our atomic ledger?
Redis ç¡®å®æœ‰ Incr å’Œ Lua è„šæœ¬ å¯ä»¥å®ç°åŸå­åŠ å‡ã€‚ä½†æœ‰ 3 ä¸ªè‡´å‘½ä¼¤ï¼š
1. æŒä¹…åŒ–ä¸å¯é  (Durability)
 * Redis AOFï¼š
   * everysec (é»˜è®¤)ï¼šæ¯ç§’åˆ·ç›˜ã€‚å¦‚æœ Redis å®•æœºï¼Œä½ ä¼šä¸¢å¤±æœ€åä¸€ç§’çš„æ‰€æœ‰è´¦å˜æ•°æ®ã€‚å¯¹äºç™¾ä¸‡ TPS çš„ç³»ç»Ÿï¼Œè¿™æ„å‘³ç€å¯èƒ½ä¸¢å¤±å‡ åä¸‡ç¬”äº¤æ˜“ã€‚è¿™æ˜¯é‡‘èç³»ç»Ÿçš„å™©æ¢¦ã€‚
   * alwaysï¼šæ¯æ¬¡æ“ä½œéƒ½åˆ·ç›˜ã€‚æ€§èƒ½å¤ªå·®ï¼ŒRedis çš„ååé‡ä¼šæ€¥å‰§ä¸‹é™ã€‚æ€§èƒ½ä¼šæš´è·Œåˆ°å‡ ç™¾ TPSï¼Œæ¯” MySQL è¿˜æ…¢ï¼Œå¤±å»äº†ç”¨ Redis çš„æ„ä¹‰ã€‚
 * j-atomic-ledger WAL: 
2. æ€§èƒ½ç“¶é¢ˆåœ¨ç½‘ç»œ (Performance)
 * Redisï¼šæ¯ä¸€æ¬¡è´¦å˜éƒ½æ˜¯ä¸€æ¬¡ ç½‘ç»œå¾€è¿”ï¼ˆRTTï¼‰ã€‚å³ä½¿åœ¨å†…ç½‘ï¼Œå»¶è¿Ÿä¹Ÿåœ¨ 0.5ms å·¦å³ã€‚TPS ä¸Šé™è¢«ç½‘ç»œå¡æ­»ã€‚
 * j-atomic-ledgerï¼šçº¯å†…å­˜ long åŠ æ³•ï¼Œè€—æ—¶å‡ çº³ç§’ã€‚
3. ä¸šåŠ¡é€»è¾‘å—é™ (Flexibility)
 * Redisï¼šå¤æ‚çš„ä¸šåŠ¡é€»è¾‘ï¼ˆå¦‚æ£€æŸ¥å¤šç§å†»ç»“çŠ¶æ€ã€é£æ§è§„åˆ™ï¼‰å¿…é¡»å†™åœ¨ Lua è„šæœ¬ é‡Œï¼Œå¼€å‘ã€æµ‹è¯•ã€è°ƒè¯•éƒ½æå…¶ç—›è‹¦ã€‚
 * j-atomic-ledgerï¼šç›´æ¥ç”¨ Java å†™ï¼Œå¯ä»¥é›†æˆä»»ä½•å¤æ‚çš„ä¸šåŠ¡æ ¡éªŒé€»è¾‘ã€‚
### 4.6 Redis çš„ AOF + RDB ä¸ j-atomic-ledger çš„ WAL + Snapshot æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ / What's the difference between Redis's AOF + RDB and j-atomic-ledger's WAL + Snapshot?
1. ç›¸åŒç‚¹ï¼š  
  Redis çš„ RDB + AOF å’Œ j-atomic-ledger çš„ Snapshot + WAL éƒ½æ˜¯ä¸ºäº†è§£å†³æ•°æ®æŒä¹…åŒ–å’Œå¿«é€Ÿæ¢å¤çš„é—®é¢˜ã€‚ä¸¤è€…åœ¨ç›®æ ‡ä¸Šæ˜¯ä¸€è‡´çš„ã€‚
2. ä¸åŒç‚¹ï¼š
   1. æ—¥å¿—ç³»ç»Ÿ: AOF vs WAL (Chronicle Queue)ï¼š
      * Redis AOF (Append-Only File)ï¼š
        * è®°å½•å†…å®¹ï¼šè®°å½•çš„æ˜¯å‘½ä»¤æ–‡æœ¬ï¼Œä¾‹å¦‚ INCR mykeyã€‚
        * å†™å…¥æ—¶æœºï¼š
          * always: æ¯æ¡å‘½ä»¤éƒ½åŒæ­¥ fsync åˆ·ç›˜ã€‚æå®‰å…¨ï¼Œä½†ææ…¢ï¼ˆå‡ ç™¾ TPSï¼‰ï¼Œä¼šé˜»å¡ Redis ä¸»çº¿ç¨‹ã€‚
          * everysec (é»˜è®¤): æ¯ç§’å¼‚æ­¥ fsync ä¸€æ¬¡ã€‚æ€§èƒ½å¥½ï¼Œä½†æœ‰é£é™©ã€‚å¦‚æœ Redis å®•æœºï¼Œä¼šä¸¢å¤±æœ€åä¸€ç§’çš„æ•°æ®ã€‚
          * no: å®Œå…¨äº¤ç»™æ“ä½œç³»ç»Ÿå†³å®šä»€ä¹ˆæ—¶å€™åˆ·ç›˜ã€‚æœ€å¿«ï¼Œä½†æœ€ä¸å®‰å…¨ã€‚
        * æ¢å¤ï¼šé‡å¯æ—¶ï¼Œåƒæ‰§è¡Œ SQL è„šæœ¬ä¸€æ ·ï¼Œä»å¤´åˆ°å°¾é‡æ–°æ‰§è¡Œä¸€é AOF æ–‡ä»¶é‡Œçš„æ‰€æœ‰å‘½ä»¤ã€‚
      * j-atomic-ledger WAL (Chronicle Queue)
        * è®°å½•å†…å®¹ï¼šè®°å½•çš„æ˜¯äºŒè¿›åˆ¶çš„ Command å¯¹è±¡ï¼ˆå¦‚ TradeCommandï¼‰ã€‚
        * å†™å…¥æ—¶æœºï¼š
          * æ¯æ¬¡éƒ½å†™ï¼ŒåŒæ­¥æ‰§è¡Œã€‚
          * ä½¿ç”¨å†…å­˜æ˜ å°„æ–‡ä»¶ (MappedByteBuffer)ã€‚ä»£ç å±‚é¢æ˜¯â€œåŒæ­¥å†™â€ï¼Œä½†å®é™…ä¸Šåªæ˜¯å†™åˆ°äº†æ“ä½œç³»ç»Ÿçš„ Page Cacheï¼ˆå†…å­˜çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚
          * æ€§èƒ½ï¼šå‡ ä¹ç­‰åŒäºå†™å†…å­˜ï¼Œè€—æ—¶å‡ åçº³ç§’ï¼Œå®Œå…¨ä¸é˜»å¡ä¸šåŠ¡ã€‚
          * å®‰å…¨æ€§ï¼šå³ä½¿ Java è¿›ç¨‹å´©æºƒï¼Œåªè¦æ“ä½œç³»ç»Ÿæ²¡å´©ï¼ˆæ²¡æ–­ç”µï¼‰ï¼ŒOS ä¼šè´Ÿè´£æŠŠ Page Cache é‡Œçš„è„æ•°æ®åˆ·å…¥ç£ç›˜ã€‚å¯é æ€§è¿œé«˜äº everysecã€‚
          * å¯¹æ¯”ï¼šè¾¾åˆ°äº† AOF always çš„å®‰å…¨æ€§ï¼Œä½†æ‹¥æœ‰ no çš„æ€§èƒ½ã€‚
   2. å¿«ç…§ç³»ç»Ÿï¼šRDB vs Kryo Snapshot
      * Redis RDB (Redis Database)
        * è®°å½•å†…å®¹ï¼šæŸä¸€æ—¶åˆ» Redis å†…å­˜ä¸­æ‰€æœ‰æ•°æ®çš„äºŒè¿›åˆ¶å¿«ç…§ã€‚
        * ç”Ÿæˆæ–¹å¼ï¼š
          * Redis ä¼š fork() ä¸€ä¸ªå­è¿›ç¨‹ã€‚
          * å­è¿›ç¨‹è´Ÿè´£éå†å†…å­˜ï¼Œå°†æ•°æ®å†™å…¥ä¸€ä¸ªä¸´æ—¶çš„ RDB æ–‡ä»¶ã€‚
          * å†™å®Œåï¼ŒåŸå­æ›¿æ¢æ—§çš„ RDB æ–‡ä»¶ã€‚
        * ä¼˜ç‚¹ï¼š
          * ä¸é˜»å¡ä¸»è¿›ç¨‹ï¼ˆç”±å­è¿›ç¨‹å¹²æ´»ï¼‰ã€‚
          * æ¢å¤é€Ÿåº¦å¿«ï¼ˆç›´æ¥åŠ è½½äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæ¯”é‡æ”¾ AOF å¿«å¾—å¤šï¼‰ã€‚
        * ç¼ºç‚¹ï¼š
          * fork() å¼€é”€ï¼šåœ¨å†…å­˜å ç”¨å·¨å¤§æ—¶ï¼ˆå‡ å GBï¼‰ï¼Œfork å¯èƒ½ä¼šå¯¼è‡´ Redis æœåŠ¡çŸ­æš‚å¡é¡¿ï¼ˆmsçº§ï¼‰ã€‚
          * æ•°æ®ä¸¢å¤±ï¼šRDB æ˜¯å®šæ—¶ä¿å­˜çš„ï¼ˆä¾‹å¦‚ save 60 1000ï¼Œ60ç§’å†…æœ‰1000æ¬¡ä¿®æ”¹å°±ä¿å­˜ï¼‰ã€‚å¦‚æœä¸¤æ¬¡å¿«ç…§ä¹‹é—´å®•æœºï¼Œä¼šä¸¢å¤±å¤§é‡æ•°æ®ã€‚
      * j-atomic-ledger Kryo Snapshot
        * è®°å½•å†…å®¹ï¼šæŸä¸€æ—¶åˆ» LedgerPartition å†…å­˜ä¸­è¯¥åˆ†ç‰‡æ•°æ®çš„äºŒè¿›åˆ¶å¿«ç…§ã€‚
        * ç”Ÿæˆæ–¹å¼ï¼š
          * åœ¨ Disruptor æ¶ˆè´¹è€…çº¿ç¨‹ ä¸­ï¼ŒåŒæ­¥æ‰§è¡Œã€‚ 
          * å…ˆå†™å…¥ä¸´æ—¶æ–‡ä»¶ï¼Œå†åŸå­é‡å‘½åã€‚
        * ä¼˜ç‚¹ï¼š
          * æ•°æ®ç²¾å‡†ï¼šå¿«ç…§ä¸ WAL çš„ Index æ˜¯ä¸¥æ ¼å¯¹åº”çš„ï¼Œæ¢å¤æ—¶æ— ç¼è¡”æ¥ã€‚ 
          * åŸå­å†™å…¥ï¼šä¿è¯å¿«ç…§æ–‡ä»¶è¦ä¹ˆæ˜¯å®Œæ•´çš„ï¼Œè¦ä¹ˆä¸å­˜åœ¨ï¼Œç»ä¸ä¼šæŸåã€‚
        * ç¼ºç‚¹ï¼š
          * åŒæ­¥é˜»å¡ï¼šä¿å­˜å¿«ç…§æ—¶ï¼Œä¼šçŸ­æš‚é˜»å¡ Disruptor æ¶ˆè´¹è€…çº¿ç¨‹ï¼ˆå‡ ååˆ°å‡ ç™¾æ¯«ç§’ï¼‰ã€‚
          * åº”å¯¹ï¼šä½†å› ä¸ºæ˜¯å®šæœŸæ‰§è¡Œï¼ˆæ¯”å¦‚æ¯ 5ä¸‡æ¡æˆ–æ¯10åˆ†é’Ÿï¼‰ï¼Œä¸”åªåœ¨æ‰¹æ¬¡æœ«å°¾æˆ–å¿ƒè·³æ—¶æ‰§è¡Œï¼Œè¿™ç§çŸ­æš‚çš„æš‚åœå¯¹æ•´ä½“ TPS å½±å“å¾ˆå°ã€‚
   3. æ¢å¤æœºåˆ¶ï¼š
      * Redis (é€šå¸¸ AOF + RDB æ··åˆ)
        * å¯åŠ¨ï¼šå…ˆæ‰¾ RDB æ–‡ä»¶ã€‚
        * åŠ è½½ RDBï¼šå¿«é€Ÿæ¢å¤åˆ°å¿«ç…§æ—¶åˆ»çš„çŠ¶æ€ã€‚
        * é‡æ”¾ AOFï¼šå†è¯»å– RDB ä¿å­˜ä¹‹åäº§ç”Ÿçš„å¢é‡ AOF æ—¥å¿—ï¼Œè¿½å¹³æ•°æ®ã€‚
      * j-atomic-ledger (WAL + Kryo Snapshot æ··åˆ)
        * å¯åŠ¨ï¼šå…ˆæ‰¾ Snapshot æ–‡ä»¶ã€‚
        * åŠ è½½ Snapshotï¼šæ¢å¤åˆ°å¿«ç…§æ—¶åˆ»çš„çŠ¶æ€ã€‚
        * é‡æ”¾ WALï¼šè¯»å–å¿«ç…§ Index ä¹‹åçš„å¢é‡ WAL æ—¥å¿—ã€‚
## ğŸ“„ License

j-atomic-ledger is Open Source software released under the Apache 2.0 license.