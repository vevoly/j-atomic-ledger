# j-atomic-ledger
#### ä½œè€… Authorï¼šVEVOLY
> **ä¸€æ¬¾åŸºäº LMAX æ¶æ„çš„ Java é«˜æ€§èƒ½å†…å­˜äº¤æ˜“å¼•æ“ï¼Œå•æœºç™¾ä¸‡ TPSï¼Œæ”¯æŒ WAL æŒä¹…åŒ–ä¸ç§’çº§å´©æºƒæ¢å¤ã€‚**  
> A Java high-performance memory transaction engine based on the LMAX architecture, single machine million TPS, supports WAL persistence and second-level crash recovery.
---
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)
[![JDK](https://img.shields.io/badge/JDK-17%2B-green.svg)]()
[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.x-brightgreen.svg)]()
---
![img.png](img%2Fimg.png)
> **Benchmark Note / å‹æµ‹è¯´æ˜**:
> æ­¤æ¬¡æµ‹è¯•æ˜¯åœ¨ Mac M1 èŠ¯ç‰‡åªæœ‰4æ ¸çš„ç¯å¢ƒä¸‹è·‘å‡ºï¼Œå•æ ¸è·‘å‡º10ä¸‡TPSã€‚è‹¥æ˜¯16æ ¸æœåŠ¡å™¨ï¼Œè½»æ¾ä¸Šç™¾ä¸‡TPSã€‚  
> This test is run on a Mac M1 chip with only 4 cores, achieving 100,000 TPS. If it is a 16-core server, it can easily reach millions of TPS.
---

## ğŸ“– 1. Introduction / é¡¹ç›®ç®€ä»‹

### 1.1 é¡¹ç›®æ¦‚è¿° ğŸ‡¨ğŸ‡³
**j-atomic-ledger** æ˜¯ä¸€ä¸ªä¸“ä¸º **é«˜å¹¶å‘ï¼ˆHigh Concurrencyï¼‰** å’Œ **ä½å»¶è¿Ÿï¼ˆLow Latencyï¼‰** åœºæ™¯è®¾è®¡çš„é€šç”¨å†…å­˜äº¤æ˜“å¼•æ“ã€‚

åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œæ•°æ®åº“è¡Œé”ï¼ˆRow Lockï¼‰å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚**j-atomic-ledger** é‡‡ç”¨ **å†…å­˜äº‹ä»¶æº¯æºï¼ˆIn-Memory Event Sourcingï¼‰** æ¶æ„ï¼Œå°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œé€šè¿‡ **Disruptor** å®ç°å•çº¿ç¨‹æ— é”å¤„ç†ï¼Œåˆ©ç”¨ **Chronicle Queue** å®ç°çº³ç§’çº§ WAL æŒä¹…åŒ–ï¼Œé…åˆ **Kryo** å†…å­˜å¿«ç…§æŠ€æœ¯ï¼Œå®ç°äº†**å•æœºç™¾ä¸‡çº§ TPS** çš„å¤„ç†èƒ½åŠ›ï¼ŒåŒæ—¶ä¿è¯äº†æ•°æ®çš„ç»å¯¹å®‰å…¨ä¸å¼ºä¸€è‡´æ€§ã€‚

å®ƒå¹¶ä¸æ˜¯è¦å–ä»£æ•°æ®åº“ï¼Œè€Œæ˜¯ä½œä¸ºæ•°æ®åº“çš„å‰ç½®é«˜æ€§èƒ½**å†™ç¼“å†²ä¸è®¡ç®—æ ¸å¿ƒ**ï¼Œç‰¹åˆ«é€‚ç”¨äº**æ”¯ä»˜ç»“ç®—ã€è®¢å•æ’®åˆã€ç§’æ€åº“å­˜æ‰£å‡ã€è´¦å˜**ç­‰å¯¹å¹¶å‘è¦æ±‚æé«˜çš„åœºæ™¯ã€‚

### Overview ğŸ‡ºğŸ‡¸
**j-atomic-ledger** is a generic in-memory transaction engine designed for **High Concurrency** and **Low Latency** scenarios.

In traditional financial/e-commerce architectures, database row locks are often the biggest bottleneck limiting throughput. **j-atomic-ledger** adopts the **In-Memory Event Sourcing** architecture. It moves core calculations from the database to memory, achieving **Single-Node Million-Level TPS** via **Disruptor** (lock-free processing), **Chronicle Queue** (nanosecond-level WAL persistence), and **Kryo** (fast memory snapshot). It ensures absolute data safety and strong consistency.

It is not intended to replace the database but serves as a high-performance **Write Buffer & Computation Core** in front of it. It is ideal for scenarios such as **Payment Settlement, Order Matching, Flash Sales (Seckill), and Ledger Systems**.


### 1.2 è§£å†³é—®é¢˜ / Problem Solved
#### åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œ**æ•°æ®åº“è¡Œé”** å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚å½“æˆåƒä¸Šä¸‡çš„è¯·æ±‚åŒæ—¶æ“ä½œåŒä¸€ä¸ªè´¦æˆ·æ—¶ï¼Œæ•°æ®åº“è¿æ¥æ± ä¼šè¢«è€—å°½ï¼Œå¯¼è‡´ç³»ç»Ÿç˜«ç—ªã€‚
#### In traditional financial/e-commerce architectures, **Database Row Locks** are often the biggest bottleneck limiting throughput. When thousands of requests hit the same account simultaneously, the database eventually becomes unresponsive.

### 1.3 æ ¸å¿ƒç‰¹æ€§ / Key Features

- ğŸš€ **æè‡´æ€§èƒ½ (Extreme Performance)**: åŸºäº LMAX Disruptor ç¯å½¢é˜Ÿåˆ—ï¼Œå•çº¿ç¨‹æ— é”ä¸²è¡Œæ‰§è¡Œï¼Œæ¶ˆé™¤ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå•æœºè½»æ¾çªç ´ 100ä¸‡+ TPSã€‚  
  Based on LMAX Disruptor. Lock-free, single-threaded execution eliminates context switching.
- ğŸ“¦ **å†…å­˜è®¡ç®— (In-Memory Computing)**: å°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œåˆ©ç”¨ **Kryo** é«˜æ•ˆåºåˆ—åŒ–ä¸ **Chronicle Queue** é«˜æ•ˆ WAL æŒä¹…åŒ–ï¼Œå®ç° **ç§’çº§æ¢å¤**ã€‚  
  Move core computation from database to memory. Utilize **Kryo** for efficient serialization and **Chronicle Queue** for efficient WAL persistence, achieving **fast recovery** in seconds.
- ğŸ’¾ **æ•°æ®å®‰å…¨ (Crash Safe)**: é‡‡ç”¨ Write-Ahead Log (WAL) æœºåˆ¶ï¼Œæ¯ç¬”äº¤æ˜“å…ˆè½ç›˜å†å†…å­˜è®¡ç®—ï¼Œæ”¯æŒæ–­ç”µé›¶ä¸¢å¤±ã€‚  
  Uses Write-Ahead Log (Chronicle Queue). Every transaction is persisted to disk (nanosecond latency) before processing. **Zero data loss on power failure.**
- ğŸ“¸ **ç§’çº§æ¢å¤ (Fast Recovery)**: è‡ªåŠ¨åŒ–çš„å†…å­˜å¿«ç…§ (Snapshot) ä¸å¢é‡æ—¥å¿—é‡æ”¾æœºåˆ¶ï¼ŒæœåŠ¡é‡å¯è€—æ—¶ä»…éœ€æ•°ç§’ã€‚  
  Automated memory snapshots (Kryo) + Incremental WAL replay. Restores millions of records in seconds.
- ğŸ›¡ï¸ **å¹‚ç­‰å»é‡ (Idempotency)**: å†…ç½®åŸºäº BloomFilter å’Œ LRU çš„é«˜æ€§èƒ½å»é‡ç­–ç•¥ï¼Œé˜²æ­¢é‡å¤äº¤æ˜“ã€‚  
  Built-in BloomFilter and LRU strategies to prevent duplicate transactions.
- ğŸŒŠ **å‰Šå³°å¡«è°· (Backpressure)**: å†…å­˜è®¡ç®—å®Œæ¯•åï¼Œé€šè¿‡å¼‚æ­¥æ‰¹é‡æ–¹å¼è½åº“ï¼Œä¿æŠ¤åç«¯æ•°æ®åº“ä¸è¢«æµé‡æ´ªå³°å‡»ç©¿ã€‚  
  Asynchronous batch persistence protects the backend database from traffic spikes.
- ğŸ”Œ **å¼€ç®±å³ç”¨ (Easy Integration)**: æä¾› Spring Boot Starterï¼Œé›¶é…ç½®å³å¯åµŒå…¥ç°æœ‰é¡¹ç›®ï¼Œæ¥å…¥Prometheus + Grafanaã€‚  
  Provides Spring Boot Starter. Just add dependency and config. Integrated with Prometheus + Grafana.

### 1.4 é¡¹ç›®æ¶æ„ / Architecture
```mermaid
graph TD
    User(User Request) -->|HTTP/RPC| Gateway[Wallet Controller]
    
    subgraph "Core Engine (Single Node 100W+ TPS)"
        direction TB
        Gateway -->|1. Append WAL| WAL[(Chronicle WAL)]
        WAL -.->|2. Publish| Disruptor{Disruptor}
        Disruptor -->|3. Consume| Handler[Business Logic]
        
        Handler -- Check --> Idempotency[Bloom/LRU]
        Handler -- Update --> Memory[In-Memory State]
        Memory -.->|Snapshot| Snapshot[(Kryo Snapshot)]
    end

    Handler -->|4. Push| Queue[Async Queue]
    Queue -->|5. Batch Insert| DB_Worker[Batch Writer]
    DB_Worker -->|6. Persist| MySQL[(MySQL/Oracle)]
```
### 1.5 æ¶æ„å¯¹æ¯” / Comparison

| ç»´åº¦ / Dimension               | ç°æœ‰æ¶æ„ (Traditional)                   | **j-atomic-ledger**                                | **æ”¶ç›Š / Benefit**                                            |
|:-----------------------------|:-------------------------------------|:---------------------------------------------------|:------------------------------------------------------------|
| **å¹¶å‘æ¨¡å‹ / Concurrency**       | å¤šçº¿ç¨‹ + æ•°æ®åº“è¡Œé”  Multi-thread + Row Lock | **å•çº¿ç¨‹ + å†…å­˜æ— é”  Single-thread + Lock-free**          | æ— æ­»é”é£é™©ï¼Œæ€§èƒ½çº¿æ€§å¢é•¿  No Deadlocks, Linear Scalability              |
| **æŒä¹…åŒ– / Persistence**        | åŒæ­¥å†™ MySQL  Sync write to DB          | **åŒæ­¥å†™ WAL + å¼‚æ­¥å†™ MySQL  Sync write WAL + Async DB** | I/O å»¶è¿Ÿé™ä½ 1000 å€  I/O Latency reduced by 1000x               |
| **æ•°æ®ä¸€è‡´æ€§ / Consistency**      | å¼ºä¸€è‡´æ€§ (ACID)  Strong (ACID)           | **æœ€ç»ˆä¸€è‡´æ€§ (Base)  Eventual (Base)**                  | ç‰ºç‰²å¾®ç§’çº§å»¶è¿Ÿï¼Œæ¢å–æé«˜å¯ç”¨æ€§  High Availability with Microsecond Latency |
| **å»é‡ä¾èµ– / Idempotency**       | æŸ¥æ•°æ®åº“æˆ–Redis  Database or Redis        | **å†…å­˜è®¡ç®— (Bloom/LRU)  In-Memory Computing**          | 0ç½‘ç»œå¼€é”€  No Network overhead                                  |
| **å•æœº TPS / Single Node TPS** | ~2,000                               | **1,000,000+**                                     | **500 å€æå‡**                                                 |
### 1.6 é€‚ç”¨åœºæ™¯ / Use Cases
1.  **é‡‘èè´¦æˆ·ç³»ç»Ÿ**: é’±åŒ…ä½™é¢æ‰£å‡ã€è½¬è´¦ã€å……å€¼ã€‚
    Financial Systems: Wallet balance updates, transfers. 
2.  **äº¤æ˜“æ’®åˆå¼•æ“**: è‚¡ç¥¨ã€åŠ å¯†è´§å¸ã€NFT äº¤æ˜“æ’®åˆã€‚
    Matching Engine: Stock, Crypto trading. 
3.  **ç”µå•†ç§’æ€ä¸­å¿ƒ**: é«˜å¹¶å‘åº“å­˜æ‰£å‡ï¼ˆé˜²è¶…å–ï¼‰ã€‚
    Flash Sales: Inventory deduction. 
4.  **æ¸¸æˆç»æµç³»ç»Ÿ**: é“å…·å‘æ”¾ã€é‡‘å¸æµè½¬ã€ç§¯åˆ†ç»“ç®—ã€‚
    Game Economy: Item/Gold distribution. 
5.  **ç‰©è”ç½‘è®¾å¤‡ç®¡ç†**: è®¾å¤‡çŠ¶æ€å˜æ›´ã€æ•°æ®ä¸ŠæŠ¥ã€äº‹ä»¶å¤„ç†ã€‚
    IoT Management: Device state changes, data reporting.
6.  **IDç”Ÿæˆç³»ç»Ÿ**: é«˜æ•ˆã€å”¯ä¸€ã€æœ‰åºçš„ ID ç”Ÿæˆã€‚
    ID Generation: Efficient, unique, ordered IDs.

---

## ğŸš€ 2. Quick Start / å¿«é€Ÿå¼€å§‹
#### å¯ä»¥æ‰“å¼€ j-atomic-ledger-example é¡¹ç›®ï¼ŒæŸ¥çœ‹å®Œæ•´ç¤ºä¾‹ä»£ç ã€‚
### 2.1 å¼•å…¥ä¾èµ– / Add Dependency
```xml
<dependency>
    <groupId>io.github.vevoly</groupId>
    <artifactId>j-atomic-ledger-spring-boot-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```
### 2.2 é…ç½®æ–‡ä»¶ / Configuration (application.yml)
```yaml
j-atomic-ledger:
  base-dir: ./data/ledger-data # æ•°æ®å­˜å‚¨è·¯å¾„ / Data storage path
  engine-name: wallet-core     # å¼•æ“åç§° / Engine name
  partitions: 4                # åˆ†ç‰‡æ•°é‡ / Number of partitions
  queue-size: 65536            # å¼‚æ­¥è½åº“é˜Ÿåˆ— / Async DB queue size
  snapshot-interval: 50000     # å¤šå°‘æ¡åšä¸€æ¬¡å¿«ç…§ / How many records to snapshot
  enable-time-snapshot: true   # å¼€å¯æ—¶é—´å¿«ç…§ / Enable time-based snapshot
  snapshot-time-interval: 10m  # å¤šå°‘æ—¶é—´ä¿å­˜ä¸€æ¬¡å¿«ç…§ï¼Œæ”¯æŒ msã€sã€mã€hã€d å•ä½ / How often to save a snapshot, supports ms, s, m, h, d units
  batch-size: 1000             # æ‰¹é‡è½åº“å¤§å° / DB batch insert size
  idempotency: BLOOM           # å»é‡ç­–ç•¥ï¼šBLOOM or LRU / Idempotency strategy: BLOOM or LRU
```

### 2.3 æ ¸å¿ƒå®ç° / Core Implementation
#### 2.3.1 å®šä¹‰å†…å­˜çŠ¶æ€å’Œå‘½ä»¤å¯¹è±¡ / Define Memory State and Command Object
```java
// 1. å®šä¹‰ä½ çš„å†…å­˜çŠ¶æ€å¯¹è±¡ / Define your memory state (POJO)
@Data
public class WalletState implements Serializable {
    // ä½™é¢ç±»å‹ä¸ºlongï¼ˆå˜ï¼‰/ Store balance as 'long' (cents) for best performance
    private Map<Long, Long> balances = new HashMap<>();

    // Mapé‡Œå¯ä»¥æ˜¯ WalletDomain å¯¹è±¡ï¼Œæ£€æŸ¥é’±åŒ…çŠ¶æ€ / Map can be WalletDomain object, check wallet status
//    private Map<Long, WalletDomain> wallets = new HashMap<>();
}

// 2. ç»§æ‰¿BaseLedgerCommandç±»ï¼Œå®šä¹‰ä½ çš„äº¤æ˜“å‘½ä»¤ / Inherit BaseLedgerCommand, define your trade command
@Data
@EqualsAndHashCode(callSuper = true)
public class TradeCommand extends BaseLedgerCommand {

    /**
     * ä¸šåŠ¡å­—æ®µï¼šç”¨æˆ·ID.
     * Business Field: User ID.
     */
    private Long userId;

    // txId å’Œ amount å­—æ®µå·²åœ¨çˆ¶ç±»å®šä¹‰ï¼Œæ­¤å¤„æ— éœ€é‡å¤å®šä¹‰
    // txId and amount fields are defined in the parent class and do not need to be redefined here.

    /**
     * å®šä¹‰åˆ†ç‰‡è·¯ç”±è§„åˆ™.
     * Define the sharding routing rule.
     * @return è¿”å› userId çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œç¡®ä¿åŒä¸€ç”¨æˆ·çš„è¯·æ±‚è¿›å…¥åŒä¸€ä¸ª Disruptor çº¿ç¨‹
     * Return userId as a string to ensure that requests from the same user enter the same Disruptor thread.
     */
    @Override
    public String getRoutingKey() {
        return String.valueOf(userId);
    }

    /**
     * åºåˆ—åŒ–æ‰©å±•ï¼šå†™å…¥ä¸šåŠ¡å­—æ®µ. / Serialization Extension: Write business fields.
     * <p>çˆ¶ç±»å·²å¤„ç† txId å’Œ amount / txId and amount fields are handled in the parent class </p>
     */
    @Override
    protected void writeBizData(BytesOut<?> bytes) {
        bytes.writeLong(userId);
    }

    /**
     * ååºåˆ—åŒ–æ‰©å±•ï¼šè¯»å–ä¸šåŠ¡å­—æ®µ. / Deserialization Extension: Read business fields
     * <p>è¯»å–é¡ºåºå¿…é¡»ä¸å†™å…¥é¡ºåºä¸¥æ ¼ä¸€è‡´ï¼/ Must match write order!</p>
     */
    @Override
    protected void readBizData(BytesIn<?> bytes) {
        this.userId = bytes.readLong();
    }
}
```
#### 2.3.2 å®šä¹‰ä¸šåŠ¡å¤„ç†é€»è¾‘ / Define Business Logic
```java
@Component
public class WalletProcessor implements BusinessProcessor<WalletState, TradeCommand, WalletEntity> {
    @Override
    public WalletEntity process(WalletState state, TradeCommand cmd) {
        long start = System.nanoTime();
        // 1. ä¸šåŠ¡é€»è¾‘ï¼šè·å–ä½™é¢ / Business logic: Get balance
        long currentBalance = state.getBalances().getOrDefault(cmd.getUserId(), 0L);
        // 2. ä¸šåŠ¡é€»è¾‘ï¼šæ£€æŸ¥ä½™é¢ (ä»…æ‰£æ¬¾æ—¶) / Business Logic: Check balance (Only for debit)
        if (cmd.getAmount() < 0 && currentBalance + cmd.getAmount() < 0) {
            // ç›´æ¥æŠ›å¼‚å¸¸ï¼Œæ¡†æ¶ä¼šæ•è·å¹¶ä¼ é€’ç»™ CompletableFuture
            // Throw exception directly, framework will catch and pass to CompletableFuture
            throw new RuntimeException("ä½™é¢ä¸è¶³ / Insufficient Balance");
        }
        // 3. ä¿®æ”¹å†…å­˜çŠ¶æ€ / Mutate Memory State
        long newBalance = currentBalance + cmd.getAmount();
        state.getBalances().put(cmd.getUserId(), newBalance);
        // 2. è¿”å›å¢é‡å®ä½“ / Return Incremental Entity
        UserWalletEntity entity = new UserWalletEntity();
        entity.setUserId(cmd.getUserId());
        entity.setBalance(MoneyUtils.toDb(newBalance));
        // 4. ä¸»åŠ¨é€šçŸ¥ Futureï¼Œè¿”å›ç»“æœå¯¹è±¡ / Notify Future, Return Result Object
        if (cmd.getFuture() != null) {
            TradeResult result = TradeResult.success(cmd.getUserId(), cmd.getTxId(), MoneyUtils.toDb(newBalance));
            result.setLatencyNs(System.nanoTime() - start);
            // å¡«å…¥ç»“æœ / Fill in the result
            cmd.getFuture().complete(result);
        }
        return entity;
    }
}
```
#### 2.3.3 å®šä¹‰å¼‚æ­¥è½åº“é€»è¾‘ / Define Asynchronous Database Logic
```java
@Component
public class WalletSyncer implements BatchWriter<WalletEntity> {
    
    @Autowired
    private MockWalletMapper walletMapper;
    
    @Override
    public void persist(List<WalletEntity> entities) {
        // 1. ä¼˜å…ˆå†™å…¥æ•°æ®åº“ (å½’æ¡£/å…œåº•) / Write to DB first (Archival/Backup)
        walletMapper.batchUpdate(entities);
        // 2. åŒæ­¥æ›´æ–° Redis (è¯»è§†å›¾) / Sync update Redis (Read View)
    }
}
```
#### 2.3.4 å®šä¹‰å¯åŠ¨å¼•å¯¼ / Define Bootstrapping
```java
@Component
public class WalletBootstrap implements LedgerBootstrap<WalletState, TradeCommand> {
    @Override
    public WalletState getInitialState() { 
        // é€šå¸¸åœ¨æ­¤å¤„è°ƒç”¨æ•°æ®åº“ DAOï¼ŒåŠ è½½æ‰€æœ‰ç”¨æˆ·çš„ä½™é¢åˆ°å†…å­˜ä¸­ï¼ˆæ•°æ®é¢„çƒ­ï¼‰
        // Usually call the database DAO here to load all user balances into memory (data preheating)
        return new WalletState(); 
    }
    // è·å–å‘½ä»¤ç±»çš„ Class å¯¹è±¡ (Get Command Class Type)
    @Override
    public Class<TradeCommand> getCommandClass() {
        // å‘Šè¯‰å¼•æ“ååºåˆ—åŒ–ç”¨è¿™ä¸ªç±» / Tell the engine to deserialize with this class
        return TradeCommand.class; 
    }
}
```
### 2.4 è°ƒç”¨ / Usage
#### æ³¨å…¥è´¦æœ¬å¼•æ“å¹¶å¯åŠ¨ / Inject Ledger Engine and Start
> æ›´å¤šé«˜çº§ç”¨æ³•è¯·æŸ¥çœ‹ j-atomic-ledger-example æ¨¡å—ä¸­çš„ api/BenchController ç±»  
> For more advanced usage, please refer to the api/BenchController class in the j-atomic-ledger-example module
```java
@Autowired
private LedgerEngine<WalletState, TradeCommand, WalletEntity> engine;

public void trade(long uid, long amount) {
    TradeCommand cmd = new TradeCommand();
    cmd.setTxId(UUID.randomUUID().toString());
    cmd.setUserId(uid);
    cmd.setAmount(amount);
    
    // Fire and Forget (or use setFuture for sync result)
    engine.submit(cmd);
}
```
---
## ğŸ“– 3. ä½¿ç”¨æŒ‡å— / User Guide
### 3.1 å¼€å‘è§„èŒƒä¸ç”¨æˆ·å¥‘çº¦ / Development Contracts and User Contract
ä¸ºäº†ç¡®ä¿æè‡´æ€§èƒ½ä¸æ•°æ®å®‰å…¨ï¼Œç”¨æˆ·éœ€éµå¾ªä»¥ä¸‹å¥‘çº¦ï¼š  
To ensure high performance and safety, users must follow these rules:
1. **å¼ºåˆ¶ä½¿ç”¨ `long` é‡‘é¢**ï¼šä¸¥ç¦åœ¨ `TradeCommand` ä¸­ä½¿ç”¨ `BigDecimal`ã€‚è¯·åœ¨å…¥å£å¤„å°†é‡‘é¢è½¬æ¢ä¸ºæœ€å°å•ä½ï¼ˆå¦‚ï¼šå˜ï¼‰ã€‚  
   **Strictly use `long` for amounts**: Never use `BigDecimal` in `TradeCommand`. Convert amounts to atomic units (e.g., cents) at the entrance.
2. **Future å¿…é¡»æ ‡è®°ä¸º `transient`**ï¼šé˜²æ­¢ WAL å†™å…¥æ—¶åºåˆ—åŒ–å¤±è´¥ã€‚
   **Mark Future as `transient`**: The `CompletableFuture` field in Command must be `transient` to avoid serialization errors during WAL writing.
3. **Processor ç¦æ­¢ I/O**ï¼šä¸šåŠ¡é€»è¾‘è¿è¡Œåœ¨å•çº¿ç¨‹ä¸­ï¼Œä¸¥ç¦æŸ¥åº“æˆ–è¿œç¨‹è°ƒç”¨ï¼Œå¦åˆ™ååé‡ä¼šç¬é—´å´©å¡Œã€‚   
   **No I/O in Processor**: The `process()` method runs in a single thread. **Do NOT** perform any Database/Redis/Network I/O here, or the throughput will collapse.

### 3.2 Java 17+ JVM é…ç½® (Chronicle) / Chronicle Configuration
ç”±äº Java 17+ çš„æ¨¡å—åŒ–é™åˆ¶ï¼ŒChronicle Queue éœ€è¦è®¿é—®åº•å±‚ APIã€‚æœ¬åœ°å¼€å‘å·¥å…·å¯åŠ¨éœ€æ·»åŠ VMé€‰é¡¹ï¼Œç”Ÿäº§ç¯å¢ƒå¯åŠ¨æ—¶**å¿…é¡»**æ·»åŠ ä»¥ä¸‹ JVM å‚æ•°ï¼Œå¦åˆ™ä¼šæŠ¥é”™æˆ–æ€§èƒ½ä¸‹é™:  
Since Java 17+, strong encapsulation requires specific JVM flags to allow Chronicle Queue to access low-level APIs (Direct Memory/Unsafe). Add these to your startup script:
```bash
--add-exports=java.base/jdk.internal.ref=ALL-UNNAMED
--add-exports=java.base/sun.nio.ch=ALL-UNNAMED
--add-exports=jdk.unsupported/sun.misc=ALL-UNNAMED
--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED
--add-opens=jdk.compiler/com.sun.tools.javac=ALL-UNNAMED
--add-opens=java.base/java.lang=ALL-UNNAMED
--add-opens=java.base/java.lang.reflect=ALL-UNNAMED
--add-opens=java.base/java.io=ALL-UNNAMED
--add-opens=java.base/java.util=ALL-UNNAMED
```
### 3.3 å»é‡ç­–ç•¥
åœ¨é…ç½®æ–‡ä»¶ä¸­é€‰æ‹©ç­–ç•¥ / Configure in application.yml:
> * BLOOM (Default)  
å¸ƒéš†è¿‡æ»¤å™¨ï¼Œé«˜æ€§èƒ½ï¼Œæä½å†…å­˜(1åƒä¸‡æ¡è®°å½•ä»…10MB)ã€‚é€‚åˆæµ·é‡æ•°æ®å»é‡ã€‚  
High performance, low memory (10MB for 10M records). Tiny false-positive rate. Best for massive data.
> * LRU: idempotency: LRU 
100% å‡†ç¡®ï¼Œä½†å†…å­˜å ç”¨è¾ƒé«˜ã€‚é€‚åˆåªéœ€å¯¹æœ€è¿‘äº¤æ˜“å»é‡çš„åœºæ™¯ã€‚  
100% accurate. Higher memory usage. Suitable for scenarios requiring strict recent deduplication.

### 3.4 è·å–å¼‚æ­¥ç»“æœ / Get async result
> * åŒæ­¥æ¨¡å¼ï¼šå‘ Command ä¼ å…¥ Futureï¼ŒController é˜»å¡ç­‰å¾…ç»“æœã€‚  
    Sync Mode (Standard): Pass a CompletableFuture into the command. The controller waits for future.get().
> * æé€Ÿæ¨¡å¼ï¼šå‘ Command ä¼ å…¥ nullã€‚å¼•æ“è·³è¿‡é€šçŸ¥é€»è¾‘ï¼Œè·å¾—ç‰©ç†æé™ååé‡ã€‚  
    Fire-and-Forget (Extreme): Pass null as future. The engine skips notification overhead, achieving maximum TPS.
### 3.5 é›†ç¾¤éƒ¨ç½²
#### j-atomic-ledger æ˜¯æœ‰çŠ¶æ€å¼•æ“ / j-atomic-ledger is a Stateful engine.
æ•¬è¯·æœŸå¾…ä¸‹ä¸ªç‰ˆæœ¬ / Coming soon in next version.
### 3.6 ç›‘æ§
å¼€å¯ Actuator ä»¥æŸ¥çœ‹æ ¸å¿ƒæŒ‡æ ‡ / Enable Spring Boot Actuator to view Micrometer metrics:  
> * j-atomic-ledger.ring.remaining: æ ¸å¿ƒé£é™©æŒ‡æ ‡ï¼Œæ¥è¿‘0è¯´æ˜å¤„ç†ä¸è¿‡æ¥ã€‚  
  Core Risk Indicator. If close to 0, consumption is too slow. ()
> * j-atomic-ledger.db.queue.size: èƒŒå‹æŒ‡æ ‡ï¼Œå †ç§¯è¯´æ˜æ•°æ®åº“æ…¢ã€‚  
  Backpressure Indicator. If high, the database is the bottleneck. 
> * j-atomic-ledger.db.batch.time: æ•°æ®åº“å†™å…¥è€—æ—¶ã€‚Database write latency. 
### 3.7 å±è”½ Chronicle å™ªéŸ³
 * å±è”½Info çº§åˆ«å™ªéŸ³ / Disable Chronicle Info level noise
 ``` yaml
logging:
  level:
    root: INFO
    # å±è”½ Chronicle çš„ INFO çº§åˆ«å™ªéŸ³ï¼ˆæ¯”å¦‚ç£ç›˜æ£€æŸ¥ã€æ˜ å°„æ–‡ä»¶æ‰©å®¹æ—¥å¿—ï¼‰
    # Disable Chronicle's INFO level noise (e.g. disk checks, mapped file expansion logs)
    net.openhft: WARN
 ```
 * ç¦ç”¨ Chronicle çš„ Google Analytics ä¸ŠæŠ¥ / Disable Chronicle's Google Analytics reporting
```java
 @SpringBootApplication
public class WalletApplication {
    public static void main(String[] args) {
        // ç¦ç”¨ Chronicle çš„ Google Analytics ä¸ŠæŠ¥
        // Disable Chronicle's Google Analytics reporting
        System.setProperty("chronicle.analytics.disable", "true");
        SpringApplication.run(WalletApplication.class, args);
    }
}
 ```
### 3.8 é«˜æ€§èƒ½è¯»è§†å›¾

---
## â“ 4. å¸¸è§é—®é¢˜ / FAQ 
### 4.1 å®•æœºäº†æ•°æ®ä¼šä¸¢å¤±å—ï¼Ÿ
ä¸ä¼šã€‚ æ‰€æœ‰æŒ‡ä»¤åœ¨å¤„ç†å‰éƒ½ä¼šé€šè¿‡å†…å­˜æ˜ å°„å†™å…¥ç£ç›˜ WALã€‚é‡å¯æ—¶ï¼Œå¼•æ“ä¼šè‡ªåŠ¨é‡æ”¾æ—¥å¿—ï¼Œæ•°æ®é›¶ä¸¢å¤±ã€‚    
No. Every command is written to the WAL (Write-Ahead Log) on disk using memory mapping before processing. On restart, the engine automatically replays the WAL to restore the memory state.
### 4.2 æ•°æ®åº“æŒ‚äº†æ€ä¹ˆåŠï¼Ÿ
ä¸šåŠ¡ä¸å—å½±å“ã€‚ å¼•æ“ä¾ç„¶å¯ä»¥æ¥å•å’Œè®¡ç®—ã€‚æ•°æ®ä¼šå †ç§¯åœ¨å¼‚æ­¥é˜Ÿåˆ—ä¸­ã€‚åå°çº¿ç¨‹ä¼šæ— é™é‡è¯•ï¼Œç›´åˆ°æ•°æ®åº“æ¢å¤ï¼Œè‡ªåŠ¨å°†ç§¯å‹æ•°æ®å†™å…¥ã€‚  
The engine will continue to process requests in memory. Data waiting for persistence will pile up in the AsyncQueue. The BatchWriter will retry indefinitely until the DB recovers.
### 4.3 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨WALï¼Ÿ
æ•°æ®åº“äº‹åŠ¡æ¶‰åŠéšæœº I/O å’Œé”ç«äº‰ï¼ˆæ¯«ç§’çº§ï¼‰ã€‚WAL é‡‡ç”¨é¡ºåºè¿½åŠ å†™ï¼Œé€Ÿåº¦åª²ç¾å†…å­˜ï¼ˆçº³ç§’çº§ï¼‰ã€‚è¿™æ˜¯å®ç°ç™¾ä¸‡ TPS çš„ç§˜è¯€ã€‚  
Database transactions involve random I/O and locks (ms level). WAL uses Sequential Write (append-only), which is as fast as memory (ns level). This is the secret to 1 million TPS.
### 4.4 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨Kryoåºåˆ—åŒ–ï¼Ÿ
Java åŸç”Ÿåºåˆ—åŒ–æ•ˆç‡ä½ä¸”ä½“ç§¯å¤§ã€‚Kryo ç”Ÿæˆçš„äºŒè¿›åˆ¶æå…¶ç´§å‡‘ï¼Œèƒ½æå¤§é™ä½ IO å¼€é”€ï¼Œå®ç°ç§’çº§å¯åŠ¨æ¢å¤ã€‚  
Java native serialization is slow and verbose. Kryo produces extremely compact binary data, reducing IO overhead and enabling Second-level Startup/Recovery.
### 4.5 ä¸ºä»€ä¹ˆå†…å­˜è®¡ç®—å¿…é¡»ä½¿ç”¨longï¼Ÿ
BigDecimal æ˜¯å¯¹è±¡ï¼Œä¼šäº§ç”Ÿå¤§é‡ GC å‹åŠ›ã€‚long æ˜¯ CPU åŸç”Ÿç±»å‹ã€‚åœ¨é«˜é¢‘äº¤æ˜“åœºæ™¯ä¸‹ï¼Œé›¶ GC å¯¹äºä¿æŒä½å»¶è¿Ÿè‡³å…³é‡è¦ã€‚  
BigDecimal creates objects, causing GC (Garbage Collection) pressure. long is a primitive type handled directly by the CPU. In high-frequency trading, Zero-GC is crucial for stable latency.
### 4.3 éé‡‘èç³»ç»Ÿèƒ½ç”¨å—ï¼Ÿ
å®Œå…¨å¯ä»¥ã€‚ ä»»ä½•éœ€è¦â€œä¸¥æ ¼é¡ºåºâ€å’Œâ€œé«˜ååâ€çš„åœºæ™¯éƒ½é€‚ç”¨ï¼Œä¾‹å¦‚ IM æ¶ˆæ¯ ID ç”Ÿæˆã€ç§’æ€åº“å­˜æ‰£å‡ã€å…¨å±€ç²¾å‡†é™æµ ç­‰ã€‚  
Yes. It is perfect for any scenario requiring "Strict Sequencing" and "High Throughput", such as:
IM Generation: Generating strictly increasing message IDs for chat groups.
Inventory: Flash sale inventory deduction.
Rate Limiting: Global precise sliding window counters.


## ğŸ“„ License

j-atomic-ledger is Open Source software released under the Apache 2.0 license.