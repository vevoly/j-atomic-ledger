# j-atomic-ledger
#### ä½œè€… Authorï¼šVEVOLY
> **A lightning-fast, crash-safe, in-memory transaction engine for Java.**  
> **ä¸€æ¬¾åŸºäº LMAX æ¶æ„çš„ Java é«˜æ€§èƒ½å†…å­˜äº¤æ˜“å¼•æ“ï¼Œå•æœºç™¾ä¸‡ TPSï¼Œæ”¯æŒ WAL æŒä¹…åŒ–ä¸ç§’çº§å´©æºƒæ¢å¤ã€‚**
---
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)
[![JDK](https://img.shields.io/badge/JDK-17%2B-green.svg)]()
[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.x-brightgreen.svg)]()
---
![img.png](img%2Fimg.png)
> **Benchmark Note / å‹æµ‹è¯´æ˜**:
> æ­¤æ¬¡æµ‹è¯•æ˜¯åœ¨ Mac M1 èŠ¯ç‰‡åªæœ‰4æ ¸çš„ç¯å¢ƒä¸‹è·‘å‡ºï¼Œå•æ ¸è·‘å‡º10ä¸‡TPSã€‚è‹¥æ˜¯16æ ¸æœåŠ¡å™¨ï¼Œè½»æ¾ä¸Šç™¾ä¸‡TPSã€‚  
> This test is run on a Mac M1 chip with only 4 cores, achieving 100,000 TPS. If it is a 16-core server, it can easily reach millions of TPS.
---

## ğŸ“– 1. Introduction / é¡¹ç›®ç®€ä»‹

### 1.1 é¡¹ç›®æ¦‚è¿° ğŸ‡¨ğŸ‡³
**j-atomic-ledger** æ˜¯ä¸€ä¸ªä¸“ä¸º **é«˜å¹¶å‘ï¼ˆHigh Concurrencyï¼‰** å’Œ **ä½å»¶è¿Ÿï¼ˆLow Latencyï¼‰** åœºæ™¯è®¾è®¡çš„é€šç”¨å†…å­˜äº¤æ˜“å¼•æ“ã€‚

åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œæ•°æ®åº“è¡Œé”ï¼ˆRow Lockï¼‰å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚**j-atomic-ledger** é‡‡ç”¨ **å†…å­˜äº‹ä»¶æº¯æºï¼ˆIn-Memory Event Sourcingï¼‰** æ¶æ„ï¼Œå°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œé€šè¿‡ **Disruptor** å®ç°å•çº¿ç¨‹æ— é”å¤„ç†ï¼Œåˆ©ç”¨ **Chronicle Queue** å®ç°çº³ç§’çº§ WAL æŒä¹…åŒ–ï¼Œé…åˆ **Kryo** å†…å­˜å¿«ç…§æŠ€æœ¯ï¼Œå®ç°äº†**å•æœºç™¾ä¸‡çº§ TPS** çš„å¤„ç†èƒ½åŠ›ï¼ŒåŒæ—¶ä¿è¯äº†æ•°æ®çš„ç»å¯¹å®‰å…¨ä¸å¼ºä¸€è‡´æ€§ã€‚

å®ƒå¹¶ä¸æ˜¯è¦å–ä»£æ•°æ®åº“ï¼Œè€Œæ˜¯ä½œä¸ºæ•°æ®åº“çš„å‰ç½®é«˜æ€§èƒ½**å†™ç¼“å†²ä¸è®¡ç®—æ ¸å¿ƒ**ï¼Œç‰¹åˆ«é€‚ç”¨äº**æ”¯ä»˜ç»“ç®—ã€è®¢å•æ’®åˆã€ç§’æ€åº“å­˜æ‰£å‡ã€è´¦å˜**ç­‰å¯¹å¹¶å‘è¦æ±‚æé«˜çš„åœºæ™¯ã€‚

### Overview ğŸ‡ºğŸ‡¸
**j-atomic-ledger** is a generic in-memory transaction engine designed for **High Concurrency** and **Low Latency** scenarios.

In traditional financial/e-commerce architectures, database row locks are often the biggest bottleneck limiting throughput. **j-atomic-ledger** adopts the **In-Memory Event Sourcing** architecture. It moves core calculations from the database to memory, achieving **Single-Node Million-Level TPS** via **Disruptor** (lock-free processing), **Chronicle Queue** (nanosecond-level WAL persistence), and **Kryo** (fast memory snapshot). It ensures absolute data safety and strong consistency.

It is not intended to replace the database but serves as a high-performance **Write Buffer & Computation Core** in front of it. It is ideal for scenarios such as **Payment Settlement, Order Matching, Flash Sales (Seckill), and Ledger Systems**.


### 1.2 è§£å†³é—®é¢˜ / Problem Solved
#### åœ¨ä¼ ç»Ÿçš„é‡‘è/ç”µå•†æ¶æ„ä¸­ï¼Œ**æ•°æ®åº“è¡Œé”** å¾€å¾€æ˜¯åˆ¶çº¦ååé‡çš„æœ€å¤§ç“¶é¢ˆã€‚å½“æˆåƒä¸Šä¸‡çš„è¯·æ±‚åŒæ—¶æ“ä½œåŒä¸€ä¸ªè´¦æˆ·æ—¶ï¼Œæ•°æ®åº“è¿æ¥æ± ä¼šè¢«è€—å°½ï¼Œå¯¼è‡´ç³»ç»Ÿç˜«ç—ªã€‚
#### In traditional financial/e-commerce architectures, **Database Row Locks** are often the biggest bottleneck limiting throughput. When thousands of requests hit the same account simultaneously, the database eventually becomes unresponsive.

### 1.3 æ ¸å¿ƒç‰¹æ€§ / Key Features

- ğŸš€ **æè‡´æ€§èƒ½ (Extreme Performance)**: åŸºäº LMAX Disruptor ç¯å½¢é˜Ÿåˆ—ï¼Œå•çº¿ç¨‹æ— é”ä¸²è¡Œæ‰§è¡Œï¼Œæ¶ˆé™¤ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå•æœºè½»æ¾çªç ´ 100ä¸‡+ TPSã€‚  
  Based on LMAX Disruptor. Lock-free, single-threaded execution eliminates context switching.
- ğŸ“¦ **å†…å­˜è®¡ç®— (In-Memory Computing)**: å°†æ ¸å¿ƒè®¡ç®—ä»æ•°æ®åº“ç§»è‡³å†…å­˜ï¼Œåˆ©ç”¨ **Kryo** é«˜æ•ˆåºåˆ—åŒ–ä¸ **Chronicle Queue** é«˜æ•ˆ WAL æŒä¹…åŒ–ï¼Œå®ç° **ç§’çº§æ¢å¤**ã€‚  
  Move core computation from database to memory. Utilize **Kryo** for efficient serialization and **Chronicle Queue** for efficient WAL persistence, achieving **fast recovery** in seconds.
- ğŸ’¾ **æ•°æ®å®‰å…¨ (Crash Safe)**: é‡‡ç”¨ Write-Ahead Log (WAL) æœºåˆ¶ï¼Œæ¯ç¬”äº¤æ˜“å…ˆè½ç›˜å†å†…å­˜è®¡ç®—ï¼Œæ”¯æŒæ–­ç”µé›¶ä¸¢å¤±ã€‚  
  Uses Write-Ahead Log (Chronicle Queue). Every transaction is persisted to disk (nanosecond latency) before processing. **Zero data loss on power failure.**
- ğŸ“¸ **ç§’çº§æ¢å¤ (Fast Recovery)**: è‡ªåŠ¨åŒ–çš„å†…å­˜å¿«ç…§ (Snapshot) ä¸å¢é‡æ—¥å¿—é‡æ”¾æœºåˆ¶ï¼ŒæœåŠ¡é‡å¯è€—æ—¶ä»…éœ€æ•°ç§’ã€‚  
  Automated memory snapshots (Kryo) + Incremental WAL replay. Restores millions of records in seconds.
- ğŸ›¡ï¸ **å¹‚ç­‰å»é‡ (Idempotency)**: å†…ç½®åŸºäº BloomFilter å’Œ LRU çš„é«˜æ€§èƒ½å»é‡ç­–ç•¥ï¼Œé˜²æ­¢é‡å¤äº¤æ˜“ã€‚  
  Built-in BloomFilter and LRU strategies to prevent duplicate transactions.
- ğŸŒŠ **å‰Šå³°å¡«è°· (Backpressure)**: å†…å­˜è®¡ç®—å®Œæ¯•åï¼Œé€šè¿‡å¼‚æ­¥æ‰¹é‡æ–¹å¼è½åº“ï¼Œä¿æŠ¤åç«¯æ•°æ®åº“ä¸è¢«æµé‡æ´ªå³°å‡»ç©¿ã€‚  
  Asynchronous batch persistence protects the backend database from traffic spikes.
- ğŸ”Œ **å¼€ç®±å³ç”¨ (Easy Integration)**: æä¾› Spring Boot Starterï¼Œé›¶é…ç½®å³å¯åµŒå…¥ç°æœ‰é¡¹ç›®ï¼Œæ¥å…¥Prometheus + Grafanaã€‚  
  Provides Spring Boot Starter. Just add dependency and config. Integrated with Prometheus + Grafana.

### 1.4 é¡¹ç›®æ¶æ„ / Architecture
```mermaid
graph TD
    User(User Request) -->|HTTP/RPC| Gateway[Wallet Controller]
    
    subgraph "Core Engine (Single Node 100W+ TPS)"
        direction TB
        Gateway -->|1. Append WAL| WAL[(Chronicle WAL)]
        WAL -.->|2. Publish| Disruptor{Disruptor}
        Disruptor -->|3. Consume| Handler[Business Logic]
        
        Handler -- Check --> Idempotency[Bloom/LRU]
        Handler -- Update --> Memory[In-Memory State]
        Memory -.->|Snapshot| Snapshot[(Kryo Snapshot)]
    end

    Handler -->|4. Push| Queue[Async Queue]
    Queue -->|5. Batch Insert| DB_Worker[Batch Writer]
    DB_Worker -->|6. Persist| MySQL[(MySQL/Oracle)]
```
### 1.5 æ¶æ„å¯¹æ¯” / Comparison

| ç»´åº¦ / Dimension               | ç°æœ‰æ¶æ„ (Traditional)                   | **j-atomic-ledger**                                | **æ”¶ç›Š / Benefit**                                            |
|:-----------------------------|:-------------------------------------|:---------------------------------------------------|:------------------------------------------------------------|
| **å¹¶å‘æ¨¡å‹ / Concurrency**       | å¤šçº¿ç¨‹ + æ•°æ®åº“è¡Œé”  Multi-thread + Row Lock | **å•çº¿ç¨‹ + å†…å­˜æ— é”  Single-thread + Lock-free**          | æ— æ­»é”é£é™©ï¼Œæ€§èƒ½çº¿æ€§å¢é•¿  No Deadlocks, Linear Scalability              |
| **æŒä¹…åŒ– / Persistence**        | åŒæ­¥å†™ MySQL  Sync write to DB          | **åŒæ­¥å†™ WAL + å¼‚æ­¥å†™ MySQL  Sync write WAL + Async DB** | I/O å»¶è¿Ÿé™ä½ 1000 å€  I/O Latency reduced by 1000x               |
| **æ•°æ®ä¸€è‡´æ€§ / Consistency**      | å¼ºä¸€è‡´æ€§ (ACID)  Strong (ACID)           | **æœ€ç»ˆä¸€è‡´æ€§ (Base)  Eventual (Base)**                  | ç‰ºç‰²å¾®ç§’çº§å»¶è¿Ÿï¼Œæ¢å–æé«˜å¯ç”¨æ€§  High Availability with Microsecond Latency |
| **å»é‡ä¾èµ– / Idempotency**       | æŸ¥æ•°æ®åº“æˆ–Redis  Database or Redis        | **å†…å­˜è®¡ç®— (Bloom/LRU)  In-Memory Computing**          | 0ç½‘ç»œå¼€é”€  No Network overhead                                  |
| **å•æœº TPS / Single Node TPS** | ~2,000                               | **1,000,000+**                                     | **500 å€æå‡**                                                 |
### 1.6 é€‚ç”¨åœºæ™¯ / Use Cases
1.  **é‡‘èè´¦æˆ·ç³»ç»Ÿ**: é’±åŒ…ä½™é¢æ‰£å‡ã€è½¬è´¦ã€å……å€¼ã€‚
    Financial Systems: Wallet balance updates, transfers. 
2.  **äº¤æ˜“æ’®åˆå¼•æ“**: è‚¡ç¥¨ã€åŠ å¯†è´§å¸ã€NFT äº¤æ˜“æ’®åˆã€‚
    Matching Engine: Stock, Crypto trading. 
3.  **ç”µå•†ç§’æ€ä¸­å¿ƒ**: é«˜å¹¶å‘åº“å­˜æ‰£å‡ï¼ˆé˜²è¶…å–ï¼‰ã€‚
    Flash Sales: Inventory deduction. 
4.  **æ¸¸æˆç»æµç³»ç»Ÿ**: é“å…·å‘æ”¾ã€é‡‘å¸æµè½¬ã€ç§¯åˆ†ç»“ç®—ã€‚
    Game Economy: Item/Gold distribution. 
5.  **ç‰©è”ç½‘è®¾å¤‡ç®¡ç†**: è®¾å¤‡çŠ¶æ€å˜æ›´ã€æ•°æ®ä¸ŠæŠ¥ã€äº‹ä»¶å¤„ç†ã€‚
    IoT Management: Device state changes, data reporting.
6.  **IDç”Ÿæˆç³»ç»Ÿ**: é«˜æ•ˆã€å”¯ä¸€ã€æœ‰åºçš„ ID ç”Ÿæˆã€‚
    ID Generation: Efficient, unique, ordered IDs.

---

## ğŸš€ 2. Quick Start / å¿«é€Ÿå¼€å§‹
#### å¯ä»¥æ‰“å¼€ j-atomic-ledger-example é¡¹ç›®ï¼ŒæŸ¥çœ‹å®Œæ•´ç¤ºä¾‹ä»£ç ã€‚
### 2.1 å¼•å…¥ä¾èµ– / Add Dependency
```xml
<dependency>
    <groupId>io.github.vevoly</groupId>
    <artifactId>j-atomic-ledger-spring-boot-starter</artifactId>
    <version>1.0.0</version>
</dependency>
```
### 2.2 é…ç½®æ–‡ä»¶ / Configuration (application.yml)
```yaml
j-atomic-ledger:
  base-dir: ./data/ledger-data # æ•°æ®å­˜å‚¨è·¯å¾„ / Data storage path
  engine-name: wallet-core     # å¼•æ“åç§° / Engine name
  partitions: 4                # åˆ†ç‰‡æ•°é‡ / Number of partitions
  queue-size: 65536            # å¼‚æ­¥è½åº“é˜Ÿåˆ— / Async DB queue size
  snapshot-interval: 50000     # å¤šå°‘æ¡åšä¸€æ¬¡å¿«ç…§ / How many records to snapshot
  enable-time-snapshot: true   # å¼€å¯æ—¶é—´å¿«ç…§ / Enable time-based snapshot
  snapshot-time-interval: 10m  # å¤šå°‘æ—¶é—´ä¿å­˜ä¸€æ¬¡å¿«ç…§ï¼Œæ”¯æŒ msã€sã€mã€hã€d å•ä½ / How often to save a snapshot, supports ms, s, m, h, d units
  batch-size: 1000             # æ‰¹é‡è½åº“å¤§å° / DB batch insert size
  idempotency: BLOOM           # å»é‡ç­–ç•¥ï¼šBLOOM or LRU / Idempotency strategy: BLOOM or LRU
```

### 2.3 æ ¸å¿ƒå®ç° / Core Implementation
#### 2.3.1 å®šä¹‰å†…å­˜çŠ¶æ€å’Œå‘½ä»¤å¯¹è±¡ / Define Memory State and Command Object
```java
// 1. Define your memory state (POJO)
@Data
public class WalletState implements Serializable {
    // Store balance as 'long' (cents) for best performance
    private Map<Long, Long> balances = new HashMap<>();

    // Mapé‡Œå¯ä»¥æ˜¯ WalletDomain å¯¹è±¡ï¼Œæ£€æŸ¥é’±åŒ…çŠ¶æ€
//    private Map<Long, WalletDomain> wallets = new HashMap<>();
}

// 2. Define your command
@Data
@EqualsAndHashCode(callSuper = true)
public class TradeCommand extends BaseLedgerCommand {
    private Long userId; // Custom field
    // txId å’Œ amount å­—æ®µå·²åœ¨çˆ¶ç±»å®šä¹‰ï¼Œæ­¤å¤„æ— éœ€é‡å¤å®šä¹‰
    
    // Define routing key for sharding (e.g., userId)
    @Override
    public String getRoutingKey() { return String.valueOf(userId); }

    // Implement efficient binary serialization
    @Override
    protected void writeBizData(BytesOut<?> bytes) { bytes.writeLong(userId); }
    @Override
    protected void readBizData(BytesIn<?> bytes) { this.userId = bytes.readLong(); }
}
```
#### 2.3.2 å®šä¹‰ä¸šåŠ¡å¤„ç†é€»è¾‘ / Define Business Logic
```java
@Component
public class WalletProcessor implements BusinessProcessor<WalletState, TradeCommand, WalletEntity> {
    @Override
    public WalletEntity process(WalletState state, TradeCommand cmd) {
        // Pure memory calculation
        long bal = state.getBalances().getOrDefault(cmd.getUserId(), 0L);
        state.getBalances().put(cmd.getUserId(), bal + cmd.getAmount());
        
        // Return incremental entity for DB
        return new WalletEntity(cmd.getUserId(), toDecimal(bal));
    }
}
```
#### 2.3.3 å®šä¹‰å¼‚æ­¥è½åº“é€»è¾‘ / Define Asynchronous Database Logic
```java
@Component
public class WalletSyncer implements BatchWriter<WalletEntity> {
    
    @Autowired
    private MockWalletMapper walletMapper;
    
    @Override
    public void persist(List<WalletEntity> entities) {
        // Batch insert/update into DB
        walletMapper.batchUpdate(entities);
    }
}
```
#### 2.3.4 å®šä¹‰å¯åŠ¨å¼•å¯¼ / Define Bootstrapping
```java
@Component
public class WalletBootstrap implements LedgerBootstrap<WalletState, TradeCommand> {
    @Override
    public WalletState getInitialState() { return new WalletState(); } // Or load from DB
    @Override
    public Class<TradeCommand> getCommandClass() { return TradeCommand.class; }
}
```
### 2.4 è°ƒç”¨ / Usage
#### æ³¨å…¥è´¦æœ¬å¼•æ“å¹¶å¯åŠ¨ / Inject Ledger Engine and Start
> æ›´å¤šé«˜çº§ç”¨æ³•è¯·æŸ¥çœ‹ j-atomic-ledger-example æ¨¡å—ä¸­çš„ api/BenchController ç±»  
> For more advanced usage, please refer to the api/BenchController class in the j-atomic-ledger-example module
```java
@Autowired
private LedgerEngine<WalletState, TradeCommand, WalletEntity> engine;

public void trade(long uid, long amount) {
    TradeCommand cmd = new TradeCommand();
    cmd.setTxId(UUID.randomUUID().toString());
    cmd.setUserId(uid);
    cmd.setAmount(amount);
    
    // Fire and Forget (or use setFuture for sync result)
    engine.submit(cmd);
}
```
---
## ğŸ“– 3. ä½¿ç”¨æŒ‡å— / User Guide
### 3.1 å¼€å‘è§„èŒƒä¸ç”¨æˆ·å¥‘çº¦
### 3.2 ä½¿ç”¨ Chronicle
### 3.3 å»é‡ç­–ç•¥
### 3.4 è·å–å¼‚æ­¥ç»“æœ
### 3.5 é›†ç¾¤éƒ¨ç½²
### 3.6 ç›‘æ§
### 3.7 å±è”½ Chronicle çš„ INFO çº§åˆ«å™ªéŸ³
### 3.8 é«˜æ€§èƒ½è¯»è§†å›¾

---
## â“ 4. å¸¸è§é—®é¢˜ / FAQ /
### 4.1 å®•æœºäº†æ•°æ®ä¼šä¸¢å¤±å—ï¼Ÿ
### 4.2 æ•°æ®åº“æŒ‚äº†æ€ä¹ˆåŠï¼Ÿ
### 4.3 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨WALï¼Ÿ
### 4.4 ä¸ºä»€ä¹ˆè¦ä½¿ç”¨Kryoåºåˆ—åŒ–ï¼Ÿ
### 4.5 ä¸ºä»€ä¹ˆå†…å­˜è®¡ç®—å¿…é¡»ä½¿ç”¨longï¼Ÿ
### 4.3 éé‡‘èç³»ç»Ÿèƒ½ç”¨å—ï¼Ÿ


## ğŸ“„ License

j-atomic-ledger is Open Source software released under the Apache 2.0 license.