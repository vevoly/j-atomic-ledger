package io.github.vevoly.ledger.example.wallet.standalone;

import io.github.vevoly.ledger.api.BatchWriter;
import io.github.vevoly.ledger.example.wallet.entity.UserWalletEntity;
import io.github.vevoly.ledger.example.wallet.standalone.mapper.MockWalletMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * <h3>钱包批量落库实现 (Wallet Batch Writer)</h3>
 *
 * <p>
 * 此类实现了 {@link BatchWriter} 接口，负责将核心引擎产生的增量数据（实体列表）持久化到外部存储。
 * 它是 <b>CQRS（命令查询职责分离）</b> 架构中连接“内存写模型”与“磁盘/缓存读模型”的关键桥梁。
 * </p>
 *
 * <hr>
 *
 * <span style="color: gray; font-size: 0.9em;">
 * <b>Wallet Batch Persistence Implementation.</b><br>
 * Implements the {@link BatchWriter} interface to persist incremental data generated by the core engine to external storage.<br>
 * It serves as the bridge between the "In-Memory Write Model" and "Disk/Cache Read Model" in the <b>CQRS</b> architecture.
 * </span>
 *
 * <h3>生产环境最佳实践 (Production Best Practices)：</h3>
 * <ul>
 *     <li>
 *         <b>批量写入数据库 (Batch Insert/Update):</b><br>
 *         务必使用 JDBC 批量模式（如 MyBatis 的 {@code <foreach>} 或 {@code BatchExecutor}），避免循环单条插入。
 *     </li>
 *     <li>
 *         <b>同步更新缓存 (Sync Cache):</b><br>
 *         建议在此处使用 <b>Redis Pipeline</b> 更新查询视图。由于这是异步线程，写 Redis 的网络耗时不会阻塞核心交易。
 *     </li>
 * </ul>
 *
 * @author vevoly
 */
@Slf4j
@Service
public class WalletBatchWriter implements BatchWriter<UserWalletEntity> {

    @Autowired
    private MockWalletMapper walletMapper;

    /**
     * 执行批量持久化 (Execute Batch Persistence).
     *
     * <p>
     * 1. <b>归档存储：</b> 将数据写入 MySQL/Oracle，作为数据的最终兜底。<br>
     * 2. <b>读视图更新：</b> (可选) 将数据写入 Redis/ElasticSearch，供外部系统高并发查询。
     * </p>
     *
     * <hr>
     *
     * <span style="color: gray; font-size: 0.9em;">
     * <b>Execute Batch Persistence.</b><br>
     * 1. <b>Archival Storage:</b> Write to MySQL/Oracle as the source of truth.<br>
     * 2. <b>Read View Update:</b> (Optional) Write to Redis/ES for high-concurrency external queries.
     * </span>
     *
     * @param entities 增量数据列表 (List of incremental entities)
     */
    @Override
    public void persist(List<UserWalletEntity> entities) {
        // 1. 优先写入数据库 (归档/兜底) / Write to DB first (Archival/Backup)
        walletMapper.batchUpdate(entities);
        // 2. 同步更新 Redis (读视图) / Sync update Redis (Read View)
        // 使用 Pipeline 技术，将网络 RTT 降到最低 / Use Pipeline to minimize network RTT
//        updateRedisPipeline(entities);
    }

    /*
    // =========================================================
    // 参考代码：Redis Pipeline 批量更新示例
    // Reference: Redis Pipeline Batch Update Example
    // =========================================================
    private void updateRedisPipeline(List<UserWalletEntity> entities) {
        try {
            redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
                for (UserWalletEntity entity : entities) {
                    // Key: wallet:balance:{userId}
                    String key = "wallet:balance:" + entity.getUserId();
                    // Value: 余额的 BigDecimal 字符串 / String representation of the balance BigDecimal
                    String value = entity.getBalance().toPlainString();

                    // 这里的 set 不需要等待返回值，直接塞入管道 / set does not need to wait for a return value, just pipe it in
                    connection.stringCommands().set(key.getBytes(), value.getBytes());
                }
                return null; // Pipeline 不需要返回值 / Pipeline does not need a return value
            });
            // log.debug("Redis pipeline synced {} records.", entities.size());
        } catch (Exception e) {
            // ⚠️ 注意：Redis 同步失败通常建议“降级处理”或“只打日志” / Redis sync failure is usually recommended to "degrade" or "just log"
            // 不要因为缓存失败抛出异常，导致前面的 DB 事务回滚或重试死循环 / Do not throw an exception due to cache failure, causing the previous DB transaction to roll back or retry in a loop
            // 缓存的一致性可以通过 TTL 过期或定期对账来修复 / Consistency can be fixed by TTL expiration or regular reconciliation
            log.error("Redis sync failed", e);
        }
    }
     */
}
